[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "Solid organ transplantation has transformed survival for patients with end-stage organ disease. For people living with HIV (PLWH), access to transplantation has historically been limited by medical uncertainty, regulatory restrictions, and stigma. Over the past two decades, however, advances in antiretroviral therapy (ART) and transplant immunology have substantially changed the clinical landscape.\nThis project integrates HIV epidemiologic data with SRTR transplant center data to examine geographic access to HIV-experienced transplant programs across the United States.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#clinical-background",
    "href": "index.html#clinical-background",
    "title": "Overview",
    "section": "",
    "text": "Solid organ transplantation has transformed survival for patients with end-stage organ disease. For people living with HIV (PLWH), access to transplantation has historically been limited by medical uncertainty, regulatory restrictions, and stigma. Over the past two decades, however, advances in antiretroviral therapy (ART) and transplant immunology have substantially changed the clinical landscape.\nThis project integrates HIV epidemiologic data with SRTR transplant center data to examine geographic access to HIV-experienced transplant programs across the United States.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#methods",
    "href": "index.html#methods",
    "title": "Overview",
    "section": "Methods",
    "text": "Methods\nThis project evaluates geographic access to solid organ transplant centers for people living with HIV in the United States. County-level HIV prevalence data from the CDC NCHHSTP AtlasPlus system were integrated with national transplant center location data. Transplant centers were classified by activity status and HIV program participation (including HOPE Act programs).\nGeographic accessibility was estimated using drive-time isochrones generated at standardized morning departure times. Isochrones were unioned across centers and spatially joined to county and tract-level population data to estimate the number and proportion of people living with HIV within defined travel-time thresholds.\nAll data processing and spatial analyses were conducted in R using reproducible workflows built on sf, tigris, and custom functions documented throughout this site. No spatial smoothing or statistical modeling was applied unless explicitly stated.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#results",
    "href": "index.html#results",
    "title": "Overview",
    "section": "Results",
    "text": "Results\nPending",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#site-navigation",
    "href": "index.html#site-navigation",
    "title": "Overview",
    "section": "Site navigation",
    "text": "Site navigation\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#abstractsmanuscripts",
    "href": "index.html#abstractsmanuscripts",
    "title": "Overview",
    "section": "Abstracts/manuscripts",
    "text": "Abstracts/manuscripts\nThis analysis has yet to be published to date.\nAbstracts have been presented or will be presented at:\n\nIDWeek 2025\nInternational Society of Heart and Lung Transplantation 2026\nAmerican Transplant Congress 2026",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "quarto/tables.html",
    "href": "quarto/tables.html",
    "title": "Tables",
    "section": "",
    "text": "The code in this script generates tables for the manuscript.",
    "crumbs": [
      "Results",
      "Tables"
    ]
  },
  {
    "objectID": "quarto/tables.html#table-1",
    "href": "quarto/tables.html#table-1",
    "title": "Tables",
    "section": "Table 1",
    "text": "Table 1\nThe following code uses the gt package to create a Table 1 comparing cases and controls on key variables measured at the index date, to assess balance after risk-set matching. The code then saves the tables as .docx and as .png files.\n\n\nCode\n#Create a table of the post-match results to confirm that demographics were appropriately balanced\ntable1&lt;-post_match_results%&gt;%\n  mutate(age=time_length(interval(BORN, index_date_match), \"years\"))%&gt;%\n  dplyr::select(cirrhosis, CMV, HIV, diabetes, cumulative_transplant_total, current_graft_status,\n                liver_transplant, lung_transplant, heart_transplant, heartlung_transplant,\n                pancreas_transplant, intestinal_transplant,\n                age, SEX, RACE, HISPANIC, RACEETH, RURALURBAN, cryptococcus_dx_date, \n         pancreas_transplant, intestinal_transplant, patient_type)%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\ntable1%&gt;%\n  gtsummary::as_gt() %&gt;%\n  gt::gtsave(\"tables/table1_baseline.png\")\nfile.exists(\"tables/table1_baseline.docx\") && file.remove(\"tables/table1_baseline.docx\")\ntable1%&gt;%\n  gtsummary::as_gt() %&gt;%\n  gt::gtsave(\"tables/table1_baseline.docx\")",
    "crumbs": [
      "Results",
      "Tables"
    ]
  },
  {
    "objectID": "quarto/tables.html#table-2",
    "href": "quarto/tables.html#table-2",
    "title": "Tables",
    "section": "Table 2",
    "text": "Table 2\nTable 2 lists the International Classification of Diseases (ICD-9 and ICD-10) diagnosis codes used to define baseline comorbidities in the study cohort. Comorbidity definitions were specified a priori in the R/setup.R file and implemented uniformly for cases and matched controls.\nCodes were grouped by clinical condition to reflect common diagnostic categories used in transplant and claims-based research. Both ICD-9 and ICD-10 codes were included to ensure continuity across calendar years spanning the ICD-9–to–ICD-10 transition period. For each comorbidity, all qualifying diagnosis codes are shown explicitly to promote transparency and reproducibility.\nThese comorbidity definitions were used for cohort construction, matching, and covariate adjustment, and were applied using diagnosis information available prior to or at the index date to avoid conditioning on post-exposure information.\nTable 2 is provided as a reference table to facilitate replication of the analytic pipeline and to allow readers to evaluate the clinical face validity of the claims-based comorbidity definitions.\n\n\nCode\n#Table of comorbidities generated from lists created in setup.R, then exported \n\ntable2_icd &lt;- comorbidity_ICD_list%&gt;%\n  imap_dfr(., \n           ~tibble(\n             comorbidity = .y,\n             icd_codes_raw = paste(.x, collapse = \", \")\n             )\n           )%&gt;%\n  gt() %&gt;%\n  cols_label(\n    comorbidity   = \"Comorbidity\",\n    icd_codes_raw = \"ICD Codes\"\n  ) %&gt;%\n  cols_width(\n    comorbidity   ~ px(220),\n    icd_codes_raw ~ px(500)\n  ) %&gt;%\n  tab_options(\n    table.font.size = px(12)\n  )%&gt;%\n  tab_header(\n  title = \"ICD-9 and ICD-10 Codes Used to Define Comorbidities\",\n  subtitle = \"Codes grouped by clinical condition\"\n)\ntable2_icd%&gt;%\n  gt::gtsave(\"tables/table2_baseline.png\")\nfile.exists(\"tables/table2_baseline.docx\") && file.remove(\"tables/table2_baseline.docx\")\ntable2_icd%&gt;%\n  gt::gtsave(\"tables/table2_baseline.docx\")",
    "crumbs": [
      "Results",
      "Tables"
    ]
  },
  {
    "objectID": "quarto/tables.html#cost-tables",
    "href": "quarto/tables.html#cost-tables",
    "title": "Tables",
    "section": "Cost tables",
    "text": "Cost tables\nThese tables use the total costs, not the modeled longitudinal costs. Cases and controls are compared. These tables are used for exploration and validation and are not intended for the manuscript.\n\n\nCode\n#Examine costs broken down by type\ncost_broken_down%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\n\n#Examine costs broken down by type and adjusted for inflation (medians)\ncost_inflated%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type)%&gt;%\n  add_p()\n\ncost_inflated%&gt;%\n  select(patient_type, contains(c(\"IN_REV_365d_cost\", \"IN_CLM_365d_cost\", \"PS_REV_365d_cost\")))%&gt;%\n  gtsummary::tbl_summary(by=patient_type,\n                         statistic = all_continuous() ~ \"{mean} ({sd})\")%&gt;%\n  add_p()",
    "crumbs": [
      "Results",
      "Tables"
    ]
  },
  {
    "objectID": "quarto/tables.html#modeled-total-excess-costs",
    "href": "quarto/tables.html#modeled-total-excess-costs",
    "title": "Tables",
    "section": "Modeled total excess costs",
    "text": "Modeled total excess costs\nThis code uses the calculate_total_excess_costs() function in the R/functions.R file to estimate the total excess cost in cases compared with controls. see the functions site for more details about the internal workings of the function.\n\n\nCode\n#Total the grand difference between cases and controls over the entire period of follow up:\ncalculate_total_excess_costs(fit[[\"grand_total_cost_month\"]][[\"gee\"]][[\"linear\"]])",
    "crumbs": [
      "Results",
      "Tables"
    ]
  },
  {
    "objectID": "quarto/tables.html#other-portions-of-the-analysis",
    "href": "quarto/tables.html#other-portions-of-the-analysis",
    "title": "Tables",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nCreate cohort: Constructs the initial time-varying cohort of kidney transplant recipients, defining cohort entry, follow-up structure, and case/control eligibility prior to matching.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Results",
      "Tables"
    ]
  },
  {
    "objectID": "quarto/functions.html",
    "href": "quarto/functions.html",
    "title": "Functions",
    "section": "",
    "text": "The code in this script generates tables for the manuscript.",
    "crumbs": [
      "Data Loading & Setup",
      "Functions"
    ]
  },
  {
    "objectID": "quarto/functions.html#plotting-mean-monthly-costs",
    "href": "quarto/functions.html#plotting-mean-monthly-costs",
    "title": "Functions",
    "section": "Plotting mean monthly costs",
    "text": "Plotting mean monthly costs\nThe following function uses ggplot2 to create a plot of monthly costs with a risk table underneath.\nIts inputs are as follows:\n\nfitted_model: the fit object from models created in the R/models.R script\ncountdf: a data frame containing the appropriate count data for cases and controls at each time point, used to create a risk table\n\nThe function uses the emmeans function from the package of the same name to estimate months costs. The x-axis (months) is shifted to the right so that the vertical line at x=0 cleanly separate pre-index and post-index months, and cases and controls are dodged slightly so that the error bars do not overlap.\n\n\nCode\n#Function that returns a ggplot of the mean cost (with confidence interval) for cryptococcus cases and controls by month\nplot_mean_monthly_costs&lt;-function(fitted_model, countdf=final_count_df) {\n\n  #First, use emmeans to calculate the predicted values from the model assuming 30-day months, then convert to data frame\n  emm_df &lt;- emmeans(\n    fitted_model,\n    ~ patient_type | month,\n    at = list(month_offset = 30),\n    type = \"response\"\n  )%&gt;%as.data.frame()%&gt;%\n    \n    #Shifts all points and error_bars 0.5 to the right to avoid the zero-line\n    mutate(month=0.5+as.numeric(month))%&gt;%\n    \n    #Move cases 0.1 to the right and controls 0.1 to the left to improve legibility\n  mutate(month=ifelse(patient_type==\"Case\", month+0.1, month-0.1))%&gt;%\n    mutate(\n      estimate = if (\"response\" %in% names(.)) response else emmean)\n  \n  monthly_plot &lt;- list()\n  \n  # Main plot\n  monthly_plot[[\"main\"]] &lt;- ggplot(data = emm_df) +\n    geom_point(aes(x = month, y = estimate, color = patient_type)) +\n    geom_errorbar(\n      aes(\n        x = month,\n        ymin = asymp.LCL,\n        ymax = asymp.UCL,\n        color = patient_type\n      ),\n      width = 0.1\n    ) +\n    geom_vline(xintercept = 0,\n               linetype = \"dashed\",\n               color = \"gray50\") +\n    theme_classic() +\n    labs(\n      x = \"Month\",\n      y = \"Inflation-adjusted cost per month (dollars)\",\n      color = \"Patient group\"\n    )+\n    theme(legend.position = \"bottom\")\n  \n  # Risk table\n  monthly_plot[[\"risk_table\"]] &lt;- countdf %&gt;%\n    mutate(month = 0.5 + as.numeric(month),\n           y_position = ifelse(patient_type == \"Case\", 0.4, 0.6)) %&gt;%\n    ggplot() +\n    geom_text(\n      aes(x = month, y = y_position, label = n, color=patient_type),\n      size = 3\n    )+\n    coord_cartesian(ylim = c(0.3, 0.7)) +\n    theme_void() +\n    theme(\n      plot.margin = margin(t = -5, b = 5),\n      legend.position = \"none\")\n  \n  # Combine plots\n  monthly_plot[[\"main\"]] /\n    monthly_plot[[\"risk_table\"]] +\n    plot_layout(heights = c(9, 1), guides = \"keep\")+\n    plot_annotation(\n      caption = \"Bottom panel shows N at risk by month\"\n    )\n  \n}",
    "crumbs": [
      "Data Loading & Setup",
      "Functions"
    ]
  },
  {
    "objectID": "quarto/functions.html#calculating-the-number-of-potential-matches",
    "href": "quarto/functions.html#calculating-the-number-of-potential-matches",
    "title": "Functions",
    "section": "Calculating the number of potential matches",
    "text": "Calculating the number of potential matches\nThe above function is passed a control df and a number of values for a case patient, and returns the number of distinct controls which are potential matches. The matching algorithm is hard-coded.\n\n\nCode\n#Function that defines the number of potential control matches for a case\ncalculate_number_potential_matches&lt;-function(control_df,\n                                             USRDS_ID,\n                                             birthdate,\n                                             cirrhosis_status,\n                                             cmv_status,\n                                             hiv_status,\n                                             diabetes_status,\n                                             matching_date,\n                                             matching_days_since_transplant) {\n  \n  print(paste0(\"Calculating number of potential controls for patient: \", USRDS_ID))\n  control_df%&gt;%\n    \n    #Exact match on cirrhosis, CMV, HIV, and diabetes status\n    filter(cirrhosis==cirrhosis_status)%&gt;%\n    #  filter(CMV==cmv_status)%&gt;%\n    filter(HIV==hiv_status)%&gt;%\n    filter(diabetes==diabetes_status)%&gt;%\n    \n    #Risk set matching\n    filter(tstart&lt;=matching_days_since_transplant)%&gt;%\n    filter(tstop&gt;matching_days_since_transplant)%&gt;%\n    \n    #Calculate date for age calculations/etc.\n    mutate(.baseline_control_date=matching_days_since_transplant+most_recent_transplant_date)%&gt;%\n    \n    #Make sure case and control are sampled within 3 years of each other\n    filter(abs(time_length(interval(.baseline_control_date, matching_date), \"years\")) &lt;=3)%&gt;%\n    \n    #Date matching\n    #  filter(cohort_start_date&lt;=matching_date)%&gt;%\n    #  filter(cohort_stop_date&gt;matching_date)%&gt;%\n    \n    #Age&gt;=18 on index date\n    filter(time_length(interval(BORN, .baseline_control_date), \"years\") &gt;= 18)%&gt;%\n    \n    #Age difference under 10 years, calculated at sampling date\n    filter(abs(time_length(interval(BORN,.baseline_control_date), \"years\")-\n                 time_length(interval(birthdate,matching_date), \"years\")) &lt;=10)%&gt;%\n    \n    #Confirming 365 day Medicare lookback available for potential match\n    verify_medicare_primary(index_date = matching_date, medicare_coverage_df = medicare_history, cache=TRUE)%&gt;%\n    filter(medicare_primary_TF==TRUE)%&gt;%\n    \n    #Count rows after ensuring controls with mult transplants are only counted once \n    distinct(USRDS_ID)%&gt;%\n    nrow()%&gt;%\n    return()\n  \n}",
    "crumbs": [
      "Data Loading & Setup",
      "Functions"
    ]
  },
  {
    "objectID": "quarto/functions.html#total-excess-costs",
    "href": "quarto/functions.html#total-excess-costs",
    "title": "Functions",
    "section": "Total excess costs",
    "text": "Total excess costs\nThis function takes a fit object from a model and calculates the total estimated excess costs and confidence intervals. This object currently only works for models with linear links.\n\n\nCode\n# Calculate total excess costs in a model\ncalculate_total_excess_costs &lt;- function(fitted_model, link = \"linear\") {\n  \n  # Extract coefficients and vcov matrix\n  coef_df &lt;- tidy(fitted_model)\n  vcov_matrix &lt;- vcov(fitted_model)\n  \n  # Get interaction terms\n  interaction_names &lt;- coef_df %&gt;% \n    filter(str_detect(term, \":\")) %&gt;% \n    pull(term)\n  \n  if (link == \"linear\") {\n    # Sum of coefficients\n    sum_estimate &lt;- coef_df %&gt;% \n      filter(term %in% interaction_names) %&gt;% \n      pull(estimate) %&gt;% \n      sum()\n    \n    # Variance of sum\n    sum_variance &lt;- vcov_matrix[interaction_names, interaction_names] %&gt;% \n      sum()\n    \n    # Standard error and CI\n    sum_se &lt;- sqrt(sum_variance)\n    df &lt;- df.residual(fitted_model)\n    \n    tibble(\n      estimate = sum_estimate,\n      std_error = sum_se,\n      conf_low = estimate - qt(0.975, df) * std_error,\n      conf_high = estimate + qt(0.975, df) * std_error,\n      statistic = estimate / std_error,\n      p_value = 2 * pt(-abs(statistic), df)\n    )\n    \n  } else if (link == \"log\") {\n    # Get coefficients for interactions\n    coefs &lt;- coef(fitted_model)[interaction_names]\n    vcov_sub &lt;- vcov_matrix[interaction_names, interaction_names]\n    \n    # Exponentiate each coefficient\n    exp_coefs &lt;- exp(coefs)\n    \n    # Sum of exponentiated coefficients\n    sum_estimate &lt;- sum(exp_coefs)\n    \n    # Delta method for variance\n    # Gradient: derivative of sum(exp(beta)) w.r.t. each beta is exp(beta)\n    gradient &lt;- exp_coefs\n    \n    # Variance using delta method\n    sum_variance &lt;- as.numeric(t(gradient) %*% vcov_sub %*% gradient)\n    sum_se &lt;- sqrt(sum_variance)\n    \n    # CI using normal approximation (GLM)\n    tibble(\n      estimate = sum_estimate,\n      std_error = sum_se,\n      conf_low = estimate - qnorm(0.975) * std_error,\n      conf_high = estimate + qnorm(0.975) * std_error,\n      statistic = estimate / std_error,\n      p_value = 2 * pnorm(-abs(statistic))\n    )\n    \n  } else {\n    stop(\"link must be either 'linear' or 'log'\")\n  }\n}",
    "crumbs": [
      "Data Loading & Setup",
      "Functions"
    ]
  },
  {
    "objectID": "quarto/functions.html#other-portions-of-the-analysis",
    "href": "quarto/functions.html#other-portions-of-the-analysis",
    "title": "Functions",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Data Loading & Setup",
      "Functions"
    ]
  },
  {
    "objectID": "quarto/background.html",
    "href": "quarto/background.html",
    "title": "Clinical background",
    "section": "",
    "text": "Solid organ transplantation has transformed survival for patients with end-stage organ disease. For people living with HIV (PLWH), access to transplantation has historically been limited by medical uncertainty, regulatory restrictions, and stigma. Over the past two decades, durable viral suppression with modern antiretroviral therapy (ART) and accumulated transplant experience have reshaped the clinical landscape.\nThis project integrates HIV epidemiologic data with SRTR transplant center information to examine geographic access to HIV-experienced transplant programs across the United States."
  },
  {
    "objectID": "quarto/background.html#overview",
    "href": "quarto/background.html#overview",
    "title": "Clinical background",
    "section": "",
    "text": "Solid organ transplantation has transformed survival for patients with end-stage organ disease. For people living with HIV (PLWH), access to transplantation has historically been limited by medical uncertainty, regulatory restrictions, and stigma. Over the past two decades, durable viral suppression with modern antiretroviral therapy (ART) and accumulated transplant experience have reshaped the clinical landscape.\nThis project integrates HIV epidemiologic data with SRTR transplant center information to examine geographic access to HIV-experienced transplant programs across the United States."
  },
  {
    "objectID": "quarto/background.html#hiv-epidemiology-and-geography-in-the-united-states",
    "href": "quarto/background.html#hiv-epidemiology-and-geography-in-the-united-states",
    "title": "Clinical background",
    "section": "HIV epidemiology and geography in the United States",
    "text": "HIV epidemiology and geography in the United States\nNational HIV surveillance in the United States is maintained through CDC’s HIV data systems, with regularly updated public data products and technical resources: - CDC HIV Data (landing page): https://www.cdc.gov/hiv-data/index.html\n- About HIV Surveillance and Monitoring: https://www.cdc.gov/hiv-data/about/index.html\nTo support geographic analyses, CDC’s NCHHSTP AtlasPlus provides interactive tools to visualize and extract data (tables/maps/charts) for HIV and related conditions: - About AtlasPlus: https://www.cdc.gov/nchhstp/about/atlasplus.html\n- AtlasPlus (main): https://gis.cdc.gov/grasp/nchhstpatlas/main.html\n- AtlasPlus Tables: https://gis.cdc.gov/grasp/nchhstpatlas/tables.html\n- AtlasPlus Maps: https://gis.cdc.gov/grasp/nchhstpatlas/maps.html\nBecause HIV burden is geographically heterogeneous, comparing HIV prevalence patterns with the distribution of transplant programs is a clinically meaningful way to assess structural access."
  },
  {
    "objectID": "quarto/background.html#solid-organ-transplantation-in-people-with-hiv",
    "href": "quarto/background.html#solid-organ-transplantation-in-people-with-hiv",
    "title": "Clinical background",
    "section": "Solid organ transplantation in people with HIV",
    "text": "Solid organ transplantation in people with HIV\nIn the early HIV era, transplantation was often viewed as contraindicated due to concerns about opportunistic infections, drug–drug interactions, and poor outcomes. In the modern ART era, multiple cohorts and registry analyses support transplantation for carefully selected candidates living with HIV."
  },
  {
    "objectID": "quarto/background.html#kidney-transplantation",
    "href": "quarto/background.html#kidney-transplantation",
    "title": "Clinical background",
    "section": "Kidney transplantation",
    "text": "Kidney transplantation\nKidney transplantation outcomes in carefully selected recipients living with HIV have been demonstrated in multicenter prospective work in the ART era.\nSeminal multicenter trial: - Stock et al., New England Journal of Medicine (2010): https://www.nejm.org/doi/full/10.1056/NEJMoa1001197\n- PubMed record: https://pubmed.ncbi.nlm.nih.gov/21083386/"
  },
  {
    "objectID": "quarto/background.html#liver-transplantation",
    "href": "quarto/background.html#liver-transplantation",
    "title": "Clinical background",
    "section": "Liver transplantation",
    "text": "Liver transplantation\nLiver transplantation for people living with HIV (including HCV coinfection) has been evaluated in prospective multicenter U.S. cohorts.\nTerrault et al., Liver Transplantation (2012): - Full text: https://onlinelibrary.wiley.com/doi/full/10.1002/lt.23411\n- PubMed record: https://pubmed.ncbi.nlm.nih.gov/22328294/\n- Open-access PMC version: https://pmc.ncbi.nlm.nih.gov/articles/PMC3358510/"
  },
  {
    "objectID": "quarto/background.html#heart-transplantation",
    "href": "quarto/background.html#heart-transplantation",
    "title": "Clinical background",
    "section": "Heart transplantation",
    "text": "Heart transplantation\nRegistry-based analyses suggest that heart transplantation in people living with HIV can achieve acceptable outcomes in carefully selected patients with well-controlled HIV, though numbers remain relatively small and center experience is concentrated.\nExamples: - Madan et al., American Journal of Transplantation (2019) full text: https://www.amjtransplant.org/article/S1600-6135%2822%2909086-4/fulltext\n- PubMed record: https://pubmed.ncbi.nlm.nih.gov/30614612/\n- SRTR-based comparison study (open access, PMC): https://pmc.ncbi.nlm.nih.gov/articles/PMC6452439/"
  },
  {
    "objectID": "quarto/background.html#lung-transplantation",
    "href": "quarto/background.html#lung-transplantation",
    "title": "Clinical background",
    "section": "Lung transplantation",
    "text": "Lung transplantation\nLung transplantation in people living with HIV has historically been uncommon, but cohort-level experience suggests feasibility in carefully selected patients with controlled HIV, while emphasizing careful attention to rejection risk and medication interactions.\nKey cohort experience (open access, PMC): - Kern et al., Annals of the American Thoracic Society (2014): https://pmc.ncbi.nlm.nih.gov/articles/PMC4213997/\n- PubMed record: https://pubmed.ncbi.nlm.nih.gov/24964265/"
  },
  {
    "objectID": "quarto/background.html#pancreas-and-simultaneous-pancreaskidney-spk-transplantation",
    "href": "quarto/background.html#pancreas-and-simultaneous-pancreaskidney-spk-transplantation",
    "title": "Clinical background",
    "section": "Pancreas and simultaneous pancreas–kidney (SPK) transplantation",
    "text": "Pancreas and simultaneous pancreas–kidney (SPK) transplantation\nPancreas transplantation and SPK in people living with HIV remain rare and concentrated in a limited number of programs, but case reports and small series support feasibility in highly selected candidates.\nExamples: - Akhtar et al. (SPK case report), PubMed: https://pubmed.ncbi.nlm.nih.gov/22172869/\n- Miro et al. (SPK experience/literature), PubMed: https://pubmed.ncbi.nlm.nih.gov/21094878/\n- Grossi et al. (SPK series), PubMed: https://pubmed.ncbi.nlm.nih.gov/22221659/"
  },
  {
    "objectID": "quarto/background.html#the-hope-act-and-evolving-u.s.-policy",
    "href": "quarto/background.html#the-hope-act-and-evolving-u.s.-policy",
    "title": "Clinical background",
    "section": "The HOPE Act and evolving U.S. policy",
    "text": "The HOPE Act and evolving U.S. policy\nUntil 2013, federal law prohibited transplantation of organs from donors with HIV. The HIV Organ Policy Equity (HOPE) Act (Public Law 113–51) created a pathway to allow transplantation of organs from donors with HIV into recipients living with HIV under specified safeguards.\n\nHOPE Act statute PDF (Congress.gov): https://www.congress.gov/113/statute/STATUTE-127/STATUTE-127-Pg579.pdf\n\nIn late 2024, HHS finalized changes determining that kidney and liver HOPE transplants no longer require participation in IRB-approved research protocols (i.e., removing the “research-only” requirement for these organs): - HHS Final Rule (Federal Register, Nov 27, 2024): https://www.federalregister.gov/documents/2024/11/27/2024-27410/organ-procurement-and-transplantation-implementation-of-the-hiv-organ-policy-equity-hope-act\n- NIH Final Notice (Federal Register, Dec 30, 2024): https://www.federalregister.gov/documents/2024/12/30/2024-31265/final-revised-human-immunodeficiency-virus-hiv-organ-policy-equity-act-safeguards-and-research\nOPTN/HRSA maintains a central HOPE Act resource page and notes the current status of the OPTN open variance: - HRSA HOPE Act resource page: https://www.hrsa.gov/optn/professionals/resources/hope-act"
  },
  {
    "objectID": "quarto/background.html#why-geographic-analysis-matters",
    "href": "quarto/background.html#why-geographic-analysis-matters",
    "title": "Clinical background",
    "section": "Why geographic analysis matters",
    "text": "Why geographic analysis matters\nHIV burden is geographically uneven, while transplant centers are clustered in metropolitan and academic hubs. For organs with fewer programs overall (heart, lung, pancreas/SPK), geographic access constraints may be amplified.\nMapping HIV burden alongside transplant program locations and travel-time catchments (e.g., 30/60/120 minutes) supports evaluation of structural access and potential regional inequities."
  },
  {
    "objectID": "quarto/background.html#data-sources-used-in-this-project",
    "href": "quarto/background.html#data-sources-used-in-this-project",
    "title": "Clinical background",
    "section": "Data sources used in this project",
    "text": "Data sources used in this project\nHIV epidemiology (CDC) - CDC HIV Data: https://www.cdc.gov/hiv-data/index.html\n- CDC AtlasPlus: https://www.cdc.gov/nchhstp/about/atlasplus.html\nTransplant program reporting (SRTR) - SRTR home: https://www.srtr.org/\n- Program-Specific Reports: https://www.srtr.org/reports/program-specific-reports/\n- About SRTR reports: https://www.srtr.org/reports/about-srtr-reports/"
  },
  {
    "objectID": "quarto/background.html#clinical-framing-of-this-analysis",
    "href": "quarto/background.html#clinical-framing-of-this-analysis",
    "title": "Clinical background",
    "section": "Clinical framing of this analysis",
    "text": "Clinical framing of this analysis\nThis analysis does not adjudicate clinical outcomes. Instead, it addresses a structural access question:\n\nDoes the geographic distribution of HIV-experienced transplant programs align with the geographic burden of HIV disease?\n\nUnderstanding this alignment informs health equity efforts, referral networks, and transplant policy implementation."
  },
  {
    "objectID": "quarto/about.html",
    "href": "quarto/about.html",
    "title": "About",
    "section": "",
    "text": "Pending",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "quarto/about.html#other-portions-of-the-analysis",
    "href": "quarto/about.html#other-portions-of-the-analysis",
    "title": "About",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nCreate cohort: Constructs the initial time-varying cohort of kidney transplant recipients, defining cohort entry, follow-up structure, and case/control eligibility prior to matching.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "quarto/figures.html",
    "href": "quarto/figures.html",
    "title": "Figures",
    "section": "",
    "text": "The code in this script generates figures for the manuscript.",
    "crumbs": [
      "Results",
      "Figures"
    ]
  },
  {
    "objectID": "quarto/figures.html#final-flowchart",
    "href": "quarto/figures.html#final-flowchart",
    "title": "Figures",
    "section": "Final flowchart",
    "text": "Final flowchart\nThe following code uses the flowchart package to create a STROBE flowchart for the study.\n\n\nCode\n#Final STROBE flowchart\npatients_fc_matched%&gt;%\n  fc_draw()%&gt;%\n  fc_export(\"figures/flowchart.svg\",\n            width=20,\n            height=10)",
    "crumbs": [
      "Results",
      "Figures"
    ]
  },
  {
    "objectID": "quarto/figures.html#beeswarm-plot-of-total-inflated-costs",
    "href": "quarto/figures.html#beeswarm-plot-of-total-inflated-costs",
    "title": "Figures",
    "section": "Beeswarm plot of total inflated costs",
    "text": "Beeswarm plot of total inflated costs\nThe following code uses the ggbeeswarm add-on to ggplot2 to compare cases and controls in terms of total inflated costs post-index. No attempt is made to adjust for censoring or death.\n\n\nCode\n#GGplot that is beeswarm of adjusted total costs\ncost_inflated%&gt;%\n  mutate(IN_CLM_365d_cost_adjusted_total=ifelse(IN_CLM_365d_cost_adjusted_total==0, 1, IN_CLM_365d_cost_adjusted_total))%&gt;%\n  ggplot()+\n  geom_quasirandom(mapping=aes(x=patient_type, y=IN_CLM_365d_cost_adjusted_total), alpha=0.1)+\n  scale_y_log10()+\n  theme_classic()",
    "crumbs": [
      "Results",
      "Figures"
    ]
  },
  {
    "objectID": "quarto/figures.html#month-by-month-plots",
    "href": "quarto/figures.html#month-by-month-plots",
    "title": "Figures",
    "section": "Month-by-month plots",
    "text": "Month-by-month plots\nIn order to plot monthly costs predicted from the longitudinal models generated in the R/models.R script, we use the plot_mean_monthly_costs() function from the R/functions.R script to create the ggplot objects, and then save as .svg files.\n\n\nCode\n#Loop that plots the different outcomes longitudinally\n\nfor (outcome in c(\"grand_total_cost_month\", \"IN_CLM_month_total\", \"PS_REV_month_total\", \"IN_CLM_month_groupedHomeHealth\",\n                  \"IN_CLM_month_groupedHospice\",\"IN_CLM_month_groupedNonclaimauxiliary\",\"IN_CLM_month_groupedDialysis\",\n                  \"IN_CLM_month_groupedOutpatient\",\"IN_CLM_month_groupedInpatient\",\"IN_CLM_month_groupedSkilledNursingFacility\")){\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"glmmTMB\"]][[\"tweedie\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" glmmTMB\", \" \", \"tweedie.svg\"),\n         width=14,\n         height=7\n         )\n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"glmmTMB\"]][[\"linear\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" glmmTMB\", \" \", \"linear.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"gee\"]][[\"linear\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" gee\", \" \", \"linear.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"glmmTMB\"]][[\"log\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" glmmTMB\", \" \", \"log.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n  plot_mean_monthly_costs(fit[[outcome]][[\"gee\"]][[\"log\"]])\n  ggsave(filename = paste0(\"figures/Longitudinal \", outcome,\" gee\", \" \", \"log.svg\"),\n         width=14,\n         height=7\n  )\n  \n  \n}",
    "crumbs": [
      "Results",
      "Figures"
    ]
  },
  {
    "objectID": "quarto/figures.html#other-portions-of-the-analysis",
    "href": "quarto/figures.html#other-portions-of-the-analysis",
    "title": "Figures",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nCreate cohort: Constructs the initial time-varying cohort of kidney transplant recipients, defining cohort entry, follow-up structure, and case/control eligibility prior to matching.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Results",
      "Figures"
    ]
  },
  {
    "objectID": "quarto/setup.html",
    "href": "quarto/setup.html",
    "title": "Setup",
    "section": "",
    "text": "The code in this script imports libraries, initializes constants, and performs other such preparatory work for the main analysis.",
    "crumbs": [
      "Data Loading & Setup",
      "Setup"
    ]
  },
  {
    "objectID": "quarto/setup.html#libraries",
    "href": "quarto/setup.html#libraries",
    "title": "Setup",
    "section": "Libraries",
    "text": "Libraries\nThe analysis relies on a set of open-source R packages for data management, cohort construction, visualization, and statistical modeling. These libraries were selected based on their stability, community support, and suitability for large-scale longitudinal health data.\n\n\nCode\n# Libraries necessary for the analysis\n\n# Data management\nlibrary(tidyverse)\nlibrary(stringi)\nlibrary(glue)\n\n#Core library for the SRTR\nlibrary(sRtr)\n\n#Data import libraries\nlibrary(readxl)\nlibrary(readr)\nlibrary(haven)\nlibrary(mapboxapi)\nlibrary(CDCAtlas)\n\n#Geographic libraries\nlibrary(sf)\nlibrary(tigris)\nlibrary(tidycensus)\nlibrary(tmap)\nlibrary(lutz)\n\n#Table libraries\nlibrary(flextable)\nlibrary(gt)\n\n#Plotting\nlibrary(colorspace)\nlibrary(ggtext)\nlibrary(extrafont)\nlibrary(janitor)\nlibrary(ggrepel)\nlibrary(writexl)\nlibrary(plotly)\nlibrary(htmlwidgets)\nlibrary(patchwork)\nlibrary(ggbeeswarm)\nlibrary(ggpubr)\nlibrary(cowplot)\nlibrary(scales)\n\n\nThe table below lists the required packages along with links to their primary documentation.\n\n\n\n\n\n\n\n\nRequired R Packages\n\n\nLibraries used for data processing, visualization, and statistical modeling\n\n\nCategory\nR package\nDocumentation\n\n\n\n\nData management\ntidyverse\ntidyverse\n\n\nData management\nstringi\nstringi\n\n\nData management\nglue\nglue\n\n\nSRTR-specific\nsRtr\nsRtr GitHub\n\n\nData import\nreadxl\nreadxl\n\n\nData import\nreadr\nreadr\n\n\nData import\nhaven\nhaven\n\n\nData import\nmapboxapi\nmapboxapi\n\n\nData import\nCDCAtlas\nCDCAtlas GitHub\n\n\nGeographic\nsf\nsf\n\n\nGeographic\ntigris\ntigris\n\n\nGeographic\ntidycensus\ntidycensus\n\n\nGeographic\ntmap\ntmap\n\n\nGeographic\nlutz\nlutz\n\n\nTables\nflextable\nflextable\n\n\nTables\ngt\ngt\n\n\nPlotting\ncolorspace\ncolorspace\n\n\nPlotting\nggtext\nggtext\n\n\nPlotting\nextrafont\nextrafont\n\n\nPlotting\njanitor\njanitor\n\n\nPlotting\nggrepel\nggrepel\n\n\nPlotting\nwritexl\nwritexl\n\n\nPlotting\nplotly\nplotly\n\n\nPlotting\nhtmlwidgets\nhtmlwidgets\n\n\nPlotting\npatchwork\npatchwork\n\n\nPlotting\nggbeeswarm\nggbeeswarm\n\n\nPlotting\nggpubr\nggpubr\n\n\nPlotting\ncowplot\ncowplot\n\n\nPlotting\nscales\nscales",
    "crumbs": [
      "Data Loading & Setup",
      "Setup"
    ]
  },
  {
    "objectID": "quarto/setup.html#constants",
    "href": "quarto/setup.html#constants",
    "title": "Setup",
    "section": "Constants",
    "text": "Constants\nA number of analysis parameters are reused across cohort construction, matching, and cost modeling steps.\nThese constants are defined in the R/setup.R file.\n\n\nCode\norgan_list&lt;-c(\"liver\", \"kidney\", \"heart\", \"lung\", \"pancreas\")\nyear_list&lt;-c(\"2017\", \"2022\")\ndistance_list=c(\"50mile\", \"60min\", \"100mile\", \"200mile\")\n\n#List states which are continental\ncontinental_fips &lt;- c(\n  \"01\", \"04\", \"05\", \"06\", \"08\", \"09\", \"10\", \"11\", \"12\", \"13\", \"16\",\n  \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\",\n  \"27\", \"28\", \"29\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\",\n  \"37\", \"38\", \"39\", \"40\", \"41\", \"42\", \"44\", \"45\", \"46\", \"47\",\n  \"48\", \"49\", \"50\", \"51\", \"53\", \"54\", \"55\", \"56\"\n)\n\n#For isochrone analysis, we need to account for time zones in order to calculate driving time at 7 AM on the specific date\n\n#List US continental time zones\n\ntimezones&lt;-c(\"America/New_York\",\"America/Chicago\",\"America/Denver\",\"America/Los_Angeles\",\"America/Phoenix\",\n             \"America/Indiana/Indianapolis\",\"America/Kentucky/Louisville\",\"America/Detroit\")\n\nreference_date&lt;-list()\n\n# Specific date to anchor the time: First Monday in March of both years\nreference_date[[\"2022\"]] &lt;- as.Date(\"2022-03-07\")\nreference_date[[\"2017\"]] &lt;- as.Date(\"2017-03-06\")\n\n\nFor clarity, these constants are summarized below along with brief explanations of their role in the analysis.\n\n\n\n\n\n\n\n\nAnalysis Constants\n\n\nGeographic buffer definitions and time-zone parameters\n\n\nConstant\nValue\nExplanation\n\n\n\n\norgan_list\nliver, kidney, heart, lung, pancreas\nOrgans included in transplant center access analysis\n\n\nyear_list\n2017, 2022\nCalendar years evaluated for geographic access comparison\n\n\ndistance_list\n50mile, 60min, 100mile, 200mile\nDistance or drive-time buffers used to define transplant center catchment areas\n\n\ncontinental_fips\n01, 04, 05, 06, 08, 09, 10, 11, 12, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51, 53, 54, 55, 56\nFIPS codes representing continental U.S. states included in analysis\n\n\ntimezones\nAmerica/New_York, America/Chicago, America/Denver, America/Los_Angeles, America/Phoenix, America/Indiana/Indianapolis, America/Kentucky/Louisville, America/Detroit\nTime zones used to convert local 7 AM departure times to UTC for isochrone calculations\n\n\nreference_date\n2022: 2022-03-07 | 2017: 2017-03-06\nAnchor dates (first Monday in March) used for time-zone–adjusted isochrone generation",
    "crumbs": [
      "Data Loading & Setup",
      "Setup"
    ]
  },
  {
    "objectID": "quarto/setup.html#lists-of-icd-codes",
    "href": "quarto/setup.html#lists-of-icd-codes",
    "title": "Setup",
    "section": "Lists of ICD codes",
    "text": "Lists of ICD codes\nLists of ICD-9-CM and ICD-10-CM diagnosis codes were used to define cryptococcosis and relevant comorbid conditions. These code sets were curated prior to analysis and include both legacy ICD-9 codes and corresponding ICD-10 codes to allow consistent identification of conditions across the study period.\nFor appropriate references, see:\n\nhttps://cdn-links.lww.com/permalink/kn9/b/kn9_2025_06_05_roetker_1_sdc2.pdf",
    "crumbs": [
      "Data Loading & Setup",
      "Setup"
    ]
  },
  {
    "objectID": "quarto/setup.html#other-portions-of-the-analysis",
    "href": "quarto/setup.html#other-portions-of-the-analysis",
    "title": "Setup",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Data Loading & Setup",
      "Setup"
    ]
  },
  {
    "objectID": "index.html#reproducibility",
    "href": "index.html#reproducibility",
    "title": "Overview",
    "section": "Reproducibility",
    "text": "Reproducibility\nAll analyses presented on this website are fully reproducible.\nThe complete source code used to perform the full analysis and generate the tables and figures is publicly available at this GitHub repo. The R script R/main.R will run the R subscripts needed for this analysis in the order they are to be run. Model assumptions, parameter values, and analytic workflows are documented in the repository to facilitate transparency and reuse.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "quarto/unite_buffers.html",
    "href": "quarto/unite_buffers.html",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study for use in other scripts.",
    "crumbs": [
      "Data Processing",
      "Unite buffers"
    ]
  },
  {
    "objectID": "quarto/unite_buffers.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "href": "quarto/unite_buffers.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "title": "Create cohort",
    "section": "Initial data loading and preprocessing of USRDS core and transplant files",
    "text": "Initial data loading and preprocessing of USRDS core and transplant files\nThis portion of the code imports files from the USRDS data set necessary for the cryptococcus analysis. This portion makes use of the load_usrds_data() function from the usRds package as well as several tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\nThe code below loads and merges transplant records across multiple UNOS-derived files, constructs a cumulative transplant count per patient, and reshapes the data into a time-varying format that tracks graft status over time.\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)",
    "crumbs": [
      "Data Processing",
      "Unite buffers"
    ]
  },
  {
    "objectID": "quarto/unite_buffers.html#initialize-flowchart",
    "href": "quarto/unite_buffers.html#initialize-flowchart",
    "title": "Create cohort",
    "section": "Initialize flowchart",
    "text": "Initialize flowchart\nThe next component makes use of the flowchart package. This package combines two key processes in an epidemiologic analysis:\n\nDataset preparation: Sequential application of eligibility criteria to define the analytic cohort, with explicit tracking of excluded records at each step.\nSTROBE diagram preparation: STrengthening the Reporting of OBservational studies in Epidemiology diagrams visually depict the process of including/excluding patients in an observational study and grouping them into cohorts. Many journals require these as a standard Figure 1.\n\nThe code below initializes a flowchart-aware cohort object and applies sequential eligibility filters, retaining both inclusion counts and labeled exclusion steps for downstream reporting.\n\n\nCode\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)",
    "crumbs": [
      "Data Processing",
      "Unite buffers"
    ]
  },
  {
    "objectID": "quarto/unite_buffers.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "href": "quarto/unite_buffers.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "title": "Create cohort",
    "section": "Identification of comorbidities and confirmation of Medicare coverage continuity",
    "text": "Identification of comorbidities and confirmation of Medicare coverage continuity\nThis component identifies baseline comorbidities among transplant recipients using diagnosis codes derived from Medicare Institutional (Part A) and physician/supplier (Part B) claims. Diagnosis code lists defined in R/setup.R are applied uniformly across claims files to establish the presence and timing of comorbid conditions.\nThis portion makes use of the get_IN_ICD() and get_PS_ICD() functions from the usRds package to obtain dates that specific ICD codes are used for patients with a history of at least one kidney transplant in the study period.\nThe establish_dx_date() function from the usRds package uses the results of this analysis to ascertain the date when comorbidities meet the criteria for a formal diagnosis:\n\nTwo outpatient encounters or\nOne inpatient encounter\n\nIn parallel, Medicare coverage history is retrieved for all transplant recipients from the payhist file, which is part of the Core dataest. These data will be used to confirm continuous enrollment during the analytic period. We verify the absence of gaps indicating missing data, noting that every subsequent period in the dataset for a patient starts the day after the previous period ends and thereby supporting valid longitudinal assessment of diagnoses and downstream cost analyses.\nFinally, we separate cryptococcus diagnosis dates from other comorbidities for a separate list, given the key nature of the date of cryptococcus diagnosis for subsequent analyses.\n\n\nCode\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n\n#Format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)",
    "crumbs": [
      "Data Processing",
      "Unite buffers"
    ]
  },
  {
    "objectID": "quarto/unite_buffers.html#further-development-of-the-strobe-flowchart",
    "href": "quarto/unite_buffers.html#further-development-of-the-strobe-flowchart",
    "title": "Create cohort",
    "section": "Further development of the STROBE flowchart",
    "text": "Further development of the STROBE flowchart\nSubsequently, key diagnosis dates, including the date of cryptococcosis diagnosis, are merged into the analytic patient dataset.\nThis code block then extends the STROBE flowchart by integrating diagnosis timing, eligibility criteria, and coverage requirements to finalize the analytic cohorts. Patients are classified as cryptococcosis cases or potential controls based on the presence and timing of diagnosis, and sequential exclusion criteria are applied to ensure incident disease, adult status at diagnosis, and appropriate calendar-time eligibility.\nThe verify_medicare_primary() function from the usrds package is used to confirm that patients with a cryptococcus diagnosis have Medicare primary coverage for at least 365 days prior to the cryptococcus diagnosis date to ensure that the diagnosis is new and not a carryover from an unobserved period.\nThese steps culminate in the final case and control cohorts, with all inclusion and exclusion decisions explicitly tracked and visualized in the updated STROBE flow diagram.\n\n\nCode\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()",
    "crumbs": [
      "Data Processing",
      "Unite buffers"
    ]
  },
  {
    "objectID": "quarto/unite_buffers.html#creation-of-a-time-varying-cohort",
    "href": "quarto/unite_buffers.html#creation-of-a-time-varying-cohort",
    "title": "Create cohort",
    "section": "Creation of a time-varying cohort",
    "text": "Creation of a time-varying cohort\nWe use several functions from the usRds package:\n\ncreate_usrds_cohort()\nadd_cohort_covariate()\nfinalize_usrds_cohort()\n\nThese functions split each patient into multiple rows, with each row describing a discrete period of time. This captures that patients will have time-varying status for covariates such as cirrhosis status, etc.\nPatients with cryptococcus infection join the cohort on the date of cryptococcosis diagnosis, while patients without cryptococcus (potential controls) join on the date of their first kidney transplant.\n“Time since transplant” resets after each new transplant.\n\n\nCode\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")\n\n\nThe analysis then proceeds on to the execute_matching component.",
    "crumbs": [
      "Data Processing",
      "Unite buffers"
    ]
  },
  {
    "objectID": "quarto/unite_buffers.html#other-portions-of-the-analysis",
    "href": "quarto/unite_buffers.html#other-portions-of-the-analysis",
    "title": "Create cohort",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Data Processing",
      "Unite buffers"
    ]
  },
  {
    "objectID": "quarto/sample_methods.html",
    "href": "quarto/sample_methods.html",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study for use in other scripts."
  },
  {
    "objectID": "quarto/sample_methods.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "href": "quarto/sample_methods.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "title": "Create cohort",
    "section": "Initial data loading and preprocessing of USRDS core and transplant files",
    "text": "Initial data loading and preprocessing of USRDS core and transplant files\nThis portion of the code imports files from the USRDS data set necessary for the cryptococcus analysis. This portion makes use of the load_usrds_data() function from the usRds package as well as several tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\nThe code below loads and merges transplant records across multiple UNOS-derived files, constructs a cumulative transplant count per patient, and reshapes the data into a time-varying format that tracks graft status over time.\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)"
  },
  {
    "objectID": "quarto/sample_methods.html#initialize-flowchart",
    "href": "quarto/sample_methods.html#initialize-flowchart",
    "title": "Create cohort",
    "section": "Initialize flowchart",
    "text": "Initialize flowchart\nThe next component makes use of the flowchart package. This package combines two key processes in an epidemiologic analysis:\n\nDataset preparation: Sequential application of eligibility criteria to define the analytic cohort, with explicit tracking of excluded records at each step.\nSTROBE diagram preparation: STrengthening the Reporting of OBservational studies in Epidemiology diagrams visually depict the process of including/excluding patients in an observational study and grouping them into cohorts. Many journals require these as a standard Figure 1.\n\nThe code below initializes a flowchart-aware cohort object and applies sequential eligibility filters, retaining both inclusion counts and labeled exclusion steps for downstream reporting.\n\n\nCode\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)"
  },
  {
    "objectID": "quarto/sample_methods.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "href": "quarto/sample_methods.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "title": "Create cohort",
    "section": "Identification of comorbidities and confirmation of Medicare coverage continuity",
    "text": "Identification of comorbidities and confirmation of Medicare coverage continuity\nThis component identifies baseline comorbidities among transplant recipients using diagnosis codes derived from Medicare Institutional (Part A) and physician/supplier (Part B) claims. Diagnosis code lists defined in R/setup.R are applied uniformly across claims files to establish the presence and timing of comorbid conditions.\nThis portion makes use of the get_IN_ICD() and get_PS_ICD() functions from the usRds package to obtain dates that specific ICD codes are used for patients with a history of at least one kidney transplant in the study period.\nThe establish_dx_date() function from the usRds package uses the results of this analysis to ascertain the date when comorbidities meet the criteria for a formal diagnosis:\n\nTwo outpatient encounters or\nOne inpatient encounter\n\nIn parallel, Medicare coverage history is retrieved for all transplant recipients from the payhist file, which is part of the Core dataest. These data will be used to confirm continuous enrollment during the analytic period. We verify the absence of gaps indicating missing data, noting that every subsequent period in the dataset for a patient starts the day after the previous period ends and thereby supporting valid longitudinal assessment of diagnoses and downstream cost analyses.\nFinally, we separate cryptococcus diagnosis dates from other comorbidities for a separate list, given the key nature of the date of cryptococcus diagnosis for subsequent analyses.\n\n\nCode\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n\n#Format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)"
  },
  {
    "objectID": "quarto/sample_methods.html#further-development-of-the-strobe-flowchart",
    "href": "quarto/sample_methods.html#further-development-of-the-strobe-flowchart",
    "title": "Create cohort",
    "section": "Further development of the STROBE flowchart",
    "text": "Further development of the STROBE flowchart\nSubsequently, key diagnosis dates, including the date of cryptococcosis diagnosis, are merged into the analytic patient dataset.\nThis code block then extends the STROBE flowchart by integrating diagnosis timing, eligibility criteria, and coverage requirements to finalize the analytic cohorts. Patients are classified as cryptococcosis cases or potential controls based on the presence and timing of diagnosis, and sequential exclusion criteria are applied to ensure incident disease, adult status at diagnosis, and appropriate calendar-time eligibility.\nThe verify_medicare_primary() function from the usrds package is used to confirm that patients with a cryptococcus diagnosis have Medicare primary coverage for at least 365 days prior to the cryptococcus diagnosis date to ensure that the diagnosis is new and not a carryover from an unobserved period.\nThese steps culminate in the final case and control cohorts, with all inclusion and exclusion decisions explicitly tracked and visualized in the updated STROBE flow diagram.\n\n\nCode\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()"
  },
  {
    "objectID": "quarto/sample_methods.html#creation-of-a-time-varying-cohort",
    "href": "quarto/sample_methods.html#creation-of-a-time-varying-cohort",
    "title": "Create cohort",
    "section": "Creation of a time-varying cohort",
    "text": "Creation of a time-varying cohort\nWe use several functions from the usRds package:\n\ncreate_usrds_cohort()\nadd_cohort_covariate()\nfinalize_usrds_cohort()\n\nThese functions split each patient into multiple rows, with each row describing a discrete period of time. This captures that patients will have time-varying status for covariates such as cirrhosis status, etc.\nPatients with cryptococcus infection join the cohort on the date of cryptococcosis diagnosis, while patients without cryptococcus (potential controls) join on the date of their first kidney transplant.\n“Time since transplant” resets after each new transplant.\n\n\nCode\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")\n\n\nThe analysis then proceeds on to the execute_matching component."
  },
  {
    "objectID": "quarto/sample_methods.html#other-portions-of-the-analysis",
    "href": "quarto/sample_methods.html#other-portions-of-the-analysis",
    "title": "Create cohort",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/join_tracts_to_united_buffers.html",
    "href": "quarto/join_tracts_to_united_buffers.html",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study for use in other scripts.",
    "crumbs": [
      "Data Processing",
      "Join tracts to united buffers"
    ]
  },
  {
    "objectID": "quarto/join_tracts_to_united_buffers.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "href": "quarto/join_tracts_to_united_buffers.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "title": "Create cohort",
    "section": "Initial data loading and preprocessing of USRDS core and transplant files",
    "text": "Initial data loading and preprocessing of USRDS core and transplant files\nThis portion of the code imports files from the USRDS data set necessary for the cryptococcus analysis. This portion makes use of the load_usrds_data() function from the usRds package as well as several tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\nThe code below loads and merges transplant records across multiple UNOS-derived files, constructs a cumulative transplant count per patient, and reshapes the data into a time-varying format that tracks graft status over time.\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)",
    "crumbs": [
      "Data Processing",
      "Join tracts to united buffers"
    ]
  },
  {
    "objectID": "quarto/join_tracts_to_united_buffers.html#initialize-flowchart",
    "href": "quarto/join_tracts_to_united_buffers.html#initialize-flowchart",
    "title": "Create cohort",
    "section": "Initialize flowchart",
    "text": "Initialize flowchart\nThe next component makes use of the flowchart package. This package combines two key processes in an epidemiologic analysis:\n\nDataset preparation: Sequential application of eligibility criteria to define the analytic cohort, with explicit tracking of excluded records at each step.\nSTROBE diagram preparation: STrengthening the Reporting of OBservational studies in Epidemiology diagrams visually depict the process of including/excluding patients in an observational study and grouping them into cohorts. Many journals require these as a standard Figure 1.\n\nThe code below initializes a flowchart-aware cohort object and applies sequential eligibility filters, retaining both inclusion counts and labeled exclusion steps for downstream reporting.\n\n\nCode\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)",
    "crumbs": [
      "Data Processing",
      "Join tracts to united buffers"
    ]
  },
  {
    "objectID": "quarto/join_tracts_to_united_buffers.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "href": "quarto/join_tracts_to_united_buffers.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "title": "Create cohort",
    "section": "Identification of comorbidities and confirmation of Medicare coverage continuity",
    "text": "Identification of comorbidities and confirmation of Medicare coverage continuity\nThis component identifies baseline comorbidities among transplant recipients using diagnosis codes derived from Medicare Institutional (Part A) and physician/supplier (Part B) claims. Diagnosis code lists defined in R/setup.R are applied uniformly across claims files to establish the presence and timing of comorbid conditions.\nThis portion makes use of the get_IN_ICD() and get_PS_ICD() functions from the usRds package to obtain dates that specific ICD codes are used for patients with a history of at least one kidney transplant in the study period.\nThe establish_dx_date() function from the usRds package uses the results of this analysis to ascertain the date when comorbidities meet the criteria for a formal diagnosis:\n\nTwo outpatient encounters or\nOne inpatient encounter\n\nIn parallel, Medicare coverage history is retrieved for all transplant recipients from the payhist file, which is part of the Core dataest. These data will be used to confirm continuous enrollment during the analytic period. We verify the absence of gaps indicating missing data, noting that every subsequent period in the dataset for a patient starts the day after the previous period ends and thereby supporting valid longitudinal assessment of diagnoses and downstream cost analyses.\nFinally, we separate cryptococcus diagnosis dates from other comorbidities for a separate list, given the key nature of the date of cryptococcus diagnosis for subsequent analyses.\n\n\nCode\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n\n#Format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)",
    "crumbs": [
      "Data Processing",
      "Join tracts to united buffers"
    ]
  },
  {
    "objectID": "quarto/join_tracts_to_united_buffers.html#further-development-of-the-strobe-flowchart",
    "href": "quarto/join_tracts_to_united_buffers.html#further-development-of-the-strobe-flowchart",
    "title": "Create cohort",
    "section": "Further development of the STROBE flowchart",
    "text": "Further development of the STROBE flowchart\nSubsequently, key diagnosis dates, including the date of cryptococcosis diagnosis, are merged into the analytic patient dataset.\nThis code block then extends the STROBE flowchart by integrating diagnosis timing, eligibility criteria, and coverage requirements to finalize the analytic cohorts. Patients are classified as cryptococcosis cases or potential controls based on the presence and timing of diagnosis, and sequential exclusion criteria are applied to ensure incident disease, adult status at diagnosis, and appropriate calendar-time eligibility.\nThe verify_medicare_primary() function from the usrds package is used to confirm that patients with a cryptococcus diagnosis have Medicare primary coverage for at least 365 days prior to the cryptococcus diagnosis date to ensure that the diagnosis is new and not a carryover from an unobserved period.\nThese steps culminate in the final case and control cohorts, with all inclusion and exclusion decisions explicitly tracked and visualized in the updated STROBE flow diagram.\n\n\nCode\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()",
    "crumbs": [
      "Data Processing",
      "Join tracts to united buffers"
    ]
  },
  {
    "objectID": "quarto/join_tracts_to_united_buffers.html#creation-of-a-time-varying-cohort",
    "href": "quarto/join_tracts_to_united_buffers.html#creation-of-a-time-varying-cohort",
    "title": "Create cohort",
    "section": "Creation of a time-varying cohort",
    "text": "Creation of a time-varying cohort\nWe use several functions from the usRds package:\n\ncreate_usrds_cohort()\nadd_cohort_covariate()\nfinalize_usrds_cohort()\n\nThese functions split each patient into multiple rows, with each row describing a discrete period of time. This captures that patients will have time-varying status for covariates such as cirrhosis status, etc.\nPatients with cryptococcus infection join the cohort on the date of cryptococcosis diagnosis, while patients without cryptococcus (potential controls) join on the date of their first kidney transplant.\n“Time since transplant” resets after each new transplant.\n\n\nCode\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")\n\n\nThe analysis then proceeds on to the execute_matching component.",
    "crumbs": [
      "Data Processing",
      "Join tracts to united buffers"
    ]
  },
  {
    "objectID": "quarto/join_tracts_to_united_buffers.html#other-portions-of-the-analysis",
    "href": "quarto/join_tracts_to_united_buffers.html#other-portions-of-the-analysis",
    "title": "Create cohort",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Data Processing",
      "Join tracts to united buffers"
    ]
  },
  {
    "objectID": "quarto/county_geographic_calculations.html",
    "href": "quarto/county_geographic_calculations.html",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study for use in other scripts.",
    "crumbs": [
      "Data Processing",
      "County-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/county_geographic_calculations.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "href": "quarto/county_geographic_calculations.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "title": "Create cohort",
    "section": "Initial data loading and preprocessing of USRDS core and transplant files",
    "text": "Initial data loading and preprocessing of USRDS core and transplant files\nThis portion of the code imports files from the USRDS data set necessary for the cryptococcus analysis. This portion makes use of the load_usrds_data() function from the usRds package as well as several tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\nThe code below loads and merges transplant records across multiple UNOS-derived files, constructs a cumulative transplant count per patient, and reshapes the data into a time-varying format that tracks graft status over time.\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)",
    "crumbs": [
      "Data Processing",
      "County-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/county_geographic_calculations.html#initialize-flowchart",
    "href": "quarto/county_geographic_calculations.html#initialize-flowchart",
    "title": "Create cohort",
    "section": "Initialize flowchart",
    "text": "Initialize flowchart\nThe next component makes use of the flowchart package. This package combines two key processes in an epidemiologic analysis:\n\nDataset preparation: Sequential application of eligibility criteria to define the analytic cohort, with explicit tracking of excluded records at each step.\nSTROBE diagram preparation: STrengthening the Reporting of OBservational studies in Epidemiology diagrams visually depict the process of including/excluding patients in an observational study and grouping them into cohorts. Many journals require these as a standard Figure 1.\n\nThe code below initializes a flowchart-aware cohort object and applies sequential eligibility filters, retaining both inclusion counts and labeled exclusion steps for downstream reporting.\n\n\nCode\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)",
    "crumbs": [
      "Data Processing",
      "County-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/county_geographic_calculations.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "href": "quarto/county_geographic_calculations.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "title": "Create cohort",
    "section": "Identification of comorbidities and confirmation of Medicare coverage continuity",
    "text": "Identification of comorbidities and confirmation of Medicare coverage continuity\nThis component identifies baseline comorbidities among transplant recipients using diagnosis codes derived from Medicare Institutional (Part A) and physician/supplier (Part B) claims. Diagnosis code lists defined in R/setup.R are applied uniformly across claims files to establish the presence and timing of comorbid conditions.\nThis portion makes use of the get_IN_ICD() and get_PS_ICD() functions from the usRds package to obtain dates that specific ICD codes are used for patients with a history of at least one kidney transplant in the study period.\nThe establish_dx_date() function from the usRds package uses the results of this analysis to ascertain the date when comorbidities meet the criteria for a formal diagnosis:\n\nTwo outpatient encounters or\nOne inpatient encounter\n\nIn parallel, Medicare coverage history is retrieved for all transplant recipients from the payhist file, which is part of the Core dataest. These data will be used to confirm continuous enrollment during the analytic period. We verify the absence of gaps indicating missing data, noting that every subsequent period in the dataset for a patient starts the day after the previous period ends and thereby supporting valid longitudinal assessment of diagnoses and downstream cost analyses.\nFinally, we separate cryptococcus diagnosis dates from other comorbidities for a separate list, given the key nature of the date of cryptococcus diagnosis for subsequent analyses.\n\n\nCode\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n\n#Format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)",
    "crumbs": [
      "Data Processing",
      "County-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/county_geographic_calculations.html#further-development-of-the-strobe-flowchart",
    "href": "quarto/county_geographic_calculations.html#further-development-of-the-strobe-flowchart",
    "title": "Create cohort",
    "section": "Further development of the STROBE flowchart",
    "text": "Further development of the STROBE flowchart\nSubsequently, key diagnosis dates, including the date of cryptococcosis diagnosis, are merged into the analytic patient dataset.\nThis code block then extends the STROBE flowchart by integrating diagnosis timing, eligibility criteria, and coverage requirements to finalize the analytic cohorts. Patients are classified as cryptococcosis cases or potential controls based on the presence and timing of diagnosis, and sequential exclusion criteria are applied to ensure incident disease, adult status at diagnosis, and appropriate calendar-time eligibility.\nThe verify_medicare_primary() function from the usrds package is used to confirm that patients with a cryptococcus diagnosis have Medicare primary coverage for at least 365 days prior to the cryptococcus diagnosis date to ensure that the diagnosis is new and not a carryover from an unobserved period.\nThese steps culminate in the final case and control cohorts, with all inclusion and exclusion decisions explicitly tracked and visualized in the updated STROBE flow diagram.\n\n\nCode\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()",
    "crumbs": [
      "Data Processing",
      "County-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/county_geographic_calculations.html#creation-of-a-time-varying-cohort",
    "href": "quarto/county_geographic_calculations.html#creation-of-a-time-varying-cohort",
    "title": "Create cohort",
    "section": "Creation of a time-varying cohort",
    "text": "Creation of a time-varying cohort\nWe use several functions from the usRds package:\n\ncreate_usrds_cohort()\nadd_cohort_covariate()\nfinalize_usrds_cohort()\n\nThese functions split each patient into multiple rows, with each row describing a discrete period of time. This captures that patients will have time-varying status for covariates such as cirrhosis status, etc.\nPatients with cryptococcus infection join the cohort on the date of cryptococcosis diagnosis, while patients without cryptococcus (potential controls) join on the date of their first kidney transplant.\n“Time since transplant” resets after each new transplant.\n\n\nCode\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")\n\n\nThe analysis then proceeds on to the execute_matching component.",
    "crumbs": [
      "Data Processing",
      "County-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/county_geographic_calculations.html#other-portions-of-the-analysis",
    "href": "quarto/county_geographic_calculations.html#other-portions-of-the-analysis",
    "title": "Create cohort",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Data Processing",
      "County-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/calculate_aggregated_results.html",
    "href": "quarto/calculate_aggregated_results.html",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study for use in other scripts."
  },
  {
    "objectID": "quarto/calculate_aggregated_results.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "href": "quarto/calculate_aggregated_results.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "title": "Create cohort",
    "section": "Initial data loading and preprocessing of USRDS core and transplant files",
    "text": "Initial data loading and preprocessing of USRDS core and transplant files\nThis portion of the code imports files from the USRDS data set necessary for the cryptococcus analysis. This portion makes use of the load_usrds_data() function from the usRds package as well as several tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\nThe code below loads and merges transplant records across multiple UNOS-derived files, constructs a cumulative transplant count per patient, and reshapes the data into a time-varying format that tracks graft status over time.\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)"
  },
  {
    "objectID": "quarto/calculate_aggregated_results.html#initialize-flowchart",
    "href": "quarto/calculate_aggregated_results.html#initialize-flowchart",
    "title": "Create cohort",
    "section": "Initialize flowchart",
    "text": "Initialize flowchart\nThe next component makes use of the flowchart package. This package combines two key processes in an epidemiologic analysis:\n\nDataset preparation: Sequential application of eligibility criteria to define the analytic cohort, with explicit tracking of excluded records at each step.\nSTROBE diagram preparation: STrengthening the Reporting of OBservational studies in Epidemiology diagrams visually depict the process of including/excluding patients in an observational study and grouping them into cohorts. Many journals require these as a standard Figure 1.\n\nThe code below initializes a flowchart-aware cohort object and applies sequential eligibility filters, retaining both inclusion counts and labeled exclusion steps for downstream reporting.\n\n\nCode\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)"
  },
  {
    "objectID": "quarto/calculate_aggregated_results.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "href": "quarto/calculate_aggregated_results.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "title": "Create cohort",
    "section": "Identification of comorbidities and confirmation of Medicare coverage continuity",
    "text": "Identification of comorbidities and confirmation of Medicare coverage continuity\nThis component identifies baseline comorbidities among transplant recipients using diagnosis codes derived from Medicare Institutional (Part A) and physician/supplier (Part B) claims. Diagnosis code lists defined in R/setup.R are applied uniformly across claims files to establish the presence and timing of comorbid conditions.\nThis portion makes use of the get_IN_ICD() and get_PS_ICD() functions from the usRds package to obtain dates that specific ICD codes are used for patients with a history of at least one kidney transplant in the study period.\nThe establish_dx_date() function from the usRds package uses the results of this analysis to ascertain the date when comorbidities meet the criteria for a formal diagnosis:\n\nTwo outpatient encounters or\nOne inpatient encounter\n\nIn parallel, Medicare coverage history is retrieved for all transplant recipients from the payhist file, which is part of the Core dataest. These data will be used to confirm continuous enrollment during the analytic period. We verify the absence of gaps indicating missing data, noting that every subsequent period in the dataset for a patient starts the day after the previous period ends and thereby supporting valid longitudinal assessment of diagnoses and downstream cost analyses.\nFinally, we separate cryptococcus diagnosis dates from other comorbidities for a separate list, given the key nature of the date of cryptococcus diagnosis for subsequent analyses.\n\n\nCode\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n\n#Format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)"
  },
  {
    "objectID": "quarto/calculate_aggregated_results.html#further-development-of-the-strobe-flowchart",
    "href": "quarto/calculate_aggregated_results.html#further-development-of-the-strobe-flowchart",
    "title": "Create cohort",
    "section": "Further development of the STROBE flowchart",
    "text": "Further development of the STROBE flowchart\nSubsequently, key diagnosis dates, including the date of cryptococcosis diagnosis, are merged into the analytic patient dataset.\nThis code block then extends the STROBE flowchart by integrating diagnosis timing, eligibility criteria, and coverage requirements to finalize the analytic cohorts. Patients are classified as cryptococcosis cases or potential controls based on the presence and timing of diagnosis, and sequential exclusion criteria are applied to ensure incident disease, adult status at diagnosis, and appropriate calendar-time eligibility.\nThe verify_medicare_primary() function from the usrds package is used to confirm that patients with a cryptococcus diagnosis have Medicare primary coverage for at least 365 days prior to the cryptococcus diagnosis date to ensure that the diagnosis is new and not a carryover from an unobserved period.\nThese steps culminate in the final case and control cohorts, with all inclusion and exclusion decisions explicitly tracked and visualized in the updated STROBE flow diagram.\n\n\nCode\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()"
  },
  {
    "objectID": "quarto/calculate_aggregated_results.html#creation-of-a-time-varying-cohort",
    "href": "quarto/calculate_aggregated_results.html#creation-of-a-time-varying-cohort",
    "title": "Create cohort",
    "section": "Creation of a time-varying cohort",
    "text": "Creation of a time-varying cohort\nWe use several functions from the usRds package:\n\ncreate_usrds_cohort()\nadd_cohort_covariate()\nfinalize_usrds_cohort()\n\nThese functions split each patient into multiple rows, with each row describing a discrete period of time. This captures that patients will have time-varying status for covariates such as cirrhosis status, etc.\nPatients with cryptococcus infection join the cohort on the date of cryptococcosis diagnosis, while patients without cryptococcus (potential controls) join on the date of their first kidney transplant.\n“Time since transplant” resets after each new transplant.\n\n\nCode\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")\n\n\nThe analysis then proceeds on to the execute_matching component."
  },
  {
    "objectID": "quarto/calculate_aggregated_results.html#other-portions-of-the-analysis",
    "href": "quarto/calculate_aggregated_results.html#other-portions-of-the-analysis",
    "title": "Create cohort",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures"
  },
  {
    "objectID": "quarto/classify_centers.html",
    "href": "quarto/classify_centers.html",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study for use in other scripts.",
    "crumbs": [
      "Data Processing",
      "Classify centers"
    ]
  },
  {
    "objectID": "quarto/classify_centers.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "href": "quarto/classify_centers.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "title": "Create cohort",
    "section": "Initial data loading and preprocessing of USRDS core and transplant files",
    "text": "Initial data loading and preprocessing of USRDS core and transplant files\nThis portion of the code imports files from the USRDS data set necessary for the cryptococcus analysis. This portion makes use of the load_usrds_data() function from the usRds package as well as several tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\nThe code below loads and merges transplant records across multiple UNOS-derived files, constructs a cumulative transplant count per patient, and reshapes the data into a time-varying format that tracks graft status over time.\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)",
    "crumbs": [
      "Data Processing",
      "Classify centers"
    ]
  },
  {
    "objectID": "quarto/classify_centers.html#initialize-flowchart",
    "href": "quarto/classify_centers.html#initialize-flowchart",
    "title": "Create cohort",
    "section": "Initialize flowchart",
    "text": "Initialize flowchart\nThe next component makes use of the flowchart package. This package combines two key processes in an epidemiologic analysis:\n\nDataset preparation: Sequential application of eligibility criteria to define the analytic cohort, with explicit tracking of excluded records at each step.\nSTROBE diagram preparation: STrengthening the Reporting of OBservational studies in Epidemiology diagrams visually depict the process of including/excluding patients in an observational study and grouping them into cohorts. Many journals require these as a standard Figure 1.\n\nThe code below initializes a flowchart-aware cohort object and applies sequential eligibility filters, retaining both inclusion counts and labeled exclusion steps for downstream reporting.\n\n\nCode\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)",
    "crumbs": [
      "Data Processing",
      "Classify centers"
    ]
  },
  {
    "objectID": "quarto/classify_centers.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "href": "quarto/classify_centers.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "title": "Create cohort",
    "section": "Identification of comorbidities and confirmation of Medicare coverage continuity",
    "text": "Identification of comorbidities and confirmation of Medicare coverage continuity\nThis component identifies baseline comorbidities among transplant recipients using diagnosis codes derived from Medicare Institutional (Part A) and physician/supplier (Part B) claims. Diagnosis code lists defined in R/setup.R are applied uniformly across claims files to establish the presence and timing of comorbid conditions.\nThis portion makes use of the get_IN_ICD() and get_PS_ICD() functions from the usRds package to obtain dates that specific ICD codes are used for patients with a history of at least one kidney transplant in the study period.\nThe establish_dx_date() function from the usRds package uses the results of this analysis to ascertain the date when comorbidities meet the criteria for a formal diagnosis:\n\nTwo outpatient encounters or\nOne inpatient encounter\n\nIn parallel, Medicare coverage history is retrieved for all transplant recipients from the payhist file, which is part of the Core dataest. These data will be used to confirm continuous enrollment during the analytic period. We verify the absence of gaps indicating missing data, noting that every subsequent period in the dataset for a patient starts the day after the previous period ends and thereby supporting valid longitudinal assessment of diagnoses and downstream cost analyses.\nFinally, we separate cryptococcus diagnosis dates from other comorbidities for a separate list, given the key nature of the date of cryptococcus diagnosis for subsequent analyses.\n\n\nCode\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n\n#Format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)",
    "crumbs": [
      "Data Processing",
      "Classify centers"
    ]
  },
  {
    "objectID": "quarto/classify_centers.html#further-development-of-the-strobe-flowchart",
    "href": "quarto/classify_centers.html#further-development-of-the-strobe-flowchart",
    "title": "Create cohort",
    "section": "Further development of the STROBE flowchart",
    "text": "Further development of the STROBE flowchart\nSubsequently, key diagnosis dates, including the date of cryptococcosis diagnosis, are merged into the analytic patient dataset.\nThis code block then extends the STROBE flowchart by integrating diagnosis timing, eligibility criteria, and coverage requirements to finalize the analytic cohorts. Patients are classified as cryptococcosis cases or potential controls based on the presence and timing of diagnosis, and sequential exclusion criteria are applied to ensure incident disease, adult status at diagnosis, and appropriate calendar-time eligibility.\nThe verify_medicare_primary() function from the usrds package is used to confirm that patients with a cryptococcus diagnosis have Medicare primary coverage for at least 365 days prior to the cryptococcus diagnosis date to ensure that the diagnosis is new and not a carryover from an unobserved period.\nThese steps culminate in the final case and control cohorts, with all inclusion and exclusion decisions explicitly tracked and visualized in the updated STROBE flow diagram.\n\n\nCode\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()",
    "crumbs": [
      "Data Processing",
      "Classify centers"
    ]
  },
  {
    "objectID": "quarto/classify_centers.html#creation-of-a-time-varying-cohort",
    "href": "quarto/classify_centers.html#creation-of-a-time-varying-cohort",
    "title": "Create cohort",
    "section": "Creation of a time-varying cohort",
    "text": "Creation of a time-varying cohort\nWe use several functions from the usRds package:\n\ncreate_usrds_cohort()\nadd_cohort_covariate()\nfinalize_usrds_cohort()\n\nThese functions split each patient into multiple rows, with each row describing a discrete period of time. This captures that patients will have time-varying status for covariates such as cirrhosis status, etc.\nPatients with cryptococcus infection join the cohort on the date of cryptococcosis diagnosis, while patients without cryptococcus (potential controls) join on the date of their first kidney transplant.\n“Time since transplant” resets after each new transplant.\n\n\nCode\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")\n\n\nThe analysis then proceeds on to the execute_matching component.",
    "crumbs": [
      "Data Processing",
      "Classify centers"
    ]
  },
  {
    "objectID": "quarto/classify_centers.html#other-portions-of-the-analysis",
    "href": "quarto/classify_centers.html#other-portions-of-the-analysis",
    "title": "Create cohort",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Data Processing",
      "Classify centers"
    ]
  },
  {
    "objectID": "quarto/geographical_computations_for_centers.html",
    "href": "quarto/geographical_computations_for_centers.html",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study for use in other scripts.",
    "crumbs": [
      "Data Processing",
      "Center-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/geographical_computations_for_centers.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "href": "quarto/geographical_computations_for_centers.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "title": "Create cohort",
    "section": "Initial data loading and preprocessing of USRDS core and transplant files",
    "text": "Initial data loading and preprocessing of USRDS core and transplant files\nThis portion of the code imports files from the USRDS data set necessary for the cryptococcus analysis. This portion makes use of the load_usrds_data() function from the usRds package as well as several tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\nThe code below loads and merges transplant records across multiple UNOS-derived files, constructs a cumulative transplant count per patient, and reshapes the data into a time-varying format that tracks graft status over time.\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)",
    "crumbs": [
      "Data Processing",
      "Center-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/geographical_computations_for_centers.html#initialize-flowchart",
    "href": "quarto/geographical_computations_for_centers.html#initialize-flowchart",
    "title": "Create cohort",
    "section": "Initialize flowchart",
    "text": "Initialize flowchart\nThe next component makes use of the flowchart package. This package combines two key processes in an epidemiologic analysis:\n\nDataset preparation: Sequential application of eligibility criteria to define the analytic cohort, with explicit tracking of excluded records at each step.\nSTROBE diagram preparation: STrengthening the Reporting of OBservational studies in Epidemiology diagrams visually depict the process of including/excluding patients in an observational study and grouping them into cohorts. Many journals require these as a standard Figure 1.\n\nThe code below initializes a flowchart-aware cohort object and applies sequential eligibility filters, retaining both inclusion counts and labeled exclusion steps for downstream reporting.\n\n\nCode\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)",
    "crumbs": [
      "Data Processing",
      "Center-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/geographical_computations_for_centers.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "href": "quarto/geographical_computations_for_centers.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "title": "Create cohort",
    "section": "Identification of comorbidities and confirmation of Medicare coverage continuity",
    "text": "Identification of comorbidities and confirmation of Medicare coverage continuity\nThis component identifies baseline comorbidities among transplant recipients using diagnosis codes derived from Medicare Institutional (Part A) and physician/supplier (Part B) claims. Diagnosis code lists defined in R/setup.R are applied uniformly across claims files to establish the presence and timing of comorbid conditions.\nThis portion makes use of the get_IN_ICD() and get_PS_ICD() functions from the usRds package to obtain dates that specific ICD codes are used for patients with a history of at least one kidney transplant in the study period.\nThe establish_dx_date() function from the usRds package uses the results of this analysis to ascertain the date when comorbidities meet the criteria for a formal diagnosis:\n\nTwo outpatient encounters or\nOne inpatient encounter\n\nIn parallel, Medicare coverage history is retrieved for all transplant recipients from the payhist file, which is part of the Core dataest. These data will be used to confirm continuous enrollment during the analytic period. We verify the absence of gaps indicating missing data, noting that every subsequent period in the dataset for a patient starts the day after the previous period ends and thereby supporting valid longitudinal assessment of diagnoses and downstream cost analyses.\nFinally, we separate cryptococcus diagnosis dates from other comorbidities for a separate list, given the key nature of the date of cryptococcus diagnosis for subsequent analyses.\n\n\nCode\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n\n#Format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)",
    "crumbs": [
      "Data Processing",
      "Center-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/geographical_computations_for_centers.html#further-development-of-the-strobe-flowchart",
    "href": "quarto/geographical_computations_for_centers.html#further-development-of-the-strobe-flowchart",
    "title": "Create cohort",
    "section": "Further development of the STROBE flowchart",
    "text": "Further development of the STROBE flowchart\nSubsequently, key diagnosis dates, including the date of cryptococcosis diagnosis, are merged into the analytic patient dataset.\nThis code block then extends the STROBE flowchart by integrating diagnosis timing, eligibility criteria, and coverage requirements to finalize the analytic cohorts. Patients are classified as cryptococcosis cases or potential controls based on the presence and timing of diagnosis, and sequential exclusion criteria are applied to ensure incident disease, adult status at diagnosis, and appropriate calendar-time eligibility.\nThe verify_medicare_primary() function from the usrds package is used to confirm that patients with a cryptococcus diagnosis have Medicare primary coverage for at least 365 days prior to the cryptococcus diagnosis date to ensure that the diagnosis is new and not a carryover from an unobserved period.\nThese steps culminate in the final case and control cohorts, with all inclusion and exclusion decisions explicitly tracked and visualized in the updated STROBE flow diagram.\n\n\nCode\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()",
    "crumbs": [
      "Data Processing",
      "Center-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/geographical_computations_for_centers.html#creation-of-a-time-varying-cohort",
    "href": "quarto/geographical_computations_for_centers.html#creation-of-a-time-varying-cohort",
    "title": "Create cohort",
    "section": "Creation of a time-varying cohort",
    "text": "Creation of a time-varying cohort\nWe use several functions from the usRds package:\n\ncreate_usrds_cohort()\nadd_cohort_covariate()\nfinalize_usrds_cohort()\n\nThese functions split each patient into multiple rows, with each row describing a discrete period of time. This captures that patients will have time-varying status for covariates such as cirrhosis status, etc.\nPatients with cryptococcus infection join the cohort on the date of cryptococcosis diagnosis, while patients without cryptococcus (potential controls) join on the date of their first kidney transplant.\n“Time since transplant” resets after each new transplant.\n\n\nCode\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")\n\n\nThe analysis then proceeds on to the execute_matching component.",
    "crumbs": [
      "Data Processing",
      "Center-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/geographical_computations_for_centers.html#other-portions-of-the-analysis",
    "href": "quarto/geographical_computations_for_centers.html#other-portions-of-the-analysis",
    "title": "Create cohort",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Data Processing",
      "Center-level geographic calculations"
    ]
  },
  {
    "objectID": "quarto/load_data.html",
    "href": "quarto/load_data.html",
    "title": "Load data",
    "section": "",
    "text": "The code in this script loads the data needed for other scripts from multiple sources, as explained in detail below.",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/load_data.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "href": "quarto/load_data.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "title": "Create cohort",
    "section": "Initial data loading and preprocessing of USRDS core and transplant files",
    "text": "Initial data loading and preprocessing of USRDS core and transplant files\nThis portion of the code imports files from the USRDS data set necessary for the cryptococcus analysis. This portion makes use of the load_usrds_data() function from the usRds package as well as several tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\nThe code below loads and merges transplant records across multiple UNOS-derived files, constructs a cumulative transplant count per patient, and reshapes the data into a time-varying format that tracks graft status over time.\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/load_data.html#initialize-flowchart",
    "href": "quarto/load_data.html#initialize-flowchart",
    "title": "Create cohort",
    "section": "Initialize flowchart",
    "text": "Initialize flowchart\nThe next component makes use of the flowchart package. This package combines two key processes in an epidemiologic analysis:\n\nDataset preparation: Sequential application of eligibility criteria to define the analytic cohort, with explicit tracking of excluded records at each step.\nSTROBE diagram preparation: STrengthening the Reporting of OBservational studies in Epidemiology diagrams visually depict the process of including/excluding patients in an observational study and grouping them into cohorts. Many journals require these as a standard Figure 1.\n\nThe code below initializes a flowchart-aware cohort object and applies sequential eligibility filters, retaining both inclusion counts and labeled exclusion steps for downstream reporting.\n\n\nCode\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/load_data.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "href": "quarto/load_data.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "title": "Create cohort",
    "section": "Identification of comorbidities and confirmation of Medicare coverage continuity",
    "text": "Identification of comorbidities and confirmation of Medicare coverage continuity\nThis component identifies baseline comorbidities among transplant recipients using diagnosis codes derived from Medicare Institutional (Part A) and physician/supplier (Part B) claims. Diagnosis code lists defined in R/setup.R are applied uniformly across claims files to establish the presence and timing of comorbid conditions.\nThis portion makes use of the get_IN_ICD() and get_PS_ICD() functions from the usRds package to obtain dates that specific ICD codes are used for patients with a history of at least one kidney transplant in the study period.\nThe establish_dx_date() function from the usRds package uses the results of this analysis to ascertain the date when comorbidities meet the criteria for a formal diagnosis:\n\nTwo outpatient encounters or\nOne inpatient encounter\n\nIn parallel, Medicare coverage history is retrieved for all transplant recipients from the payhist file, which is part of the Core dataest. These data will be used to confirm continuous enrollment during the analytic period. We verify the absence of gaps indicating missing data, noting that every subsequent period in the dataset for a patient starts the day after the previous period ends and thereby supporting valid longitudinal assessment of diagnoses and downstream cost analyses.\nFinally, we separate cryptococcus diagnosis dates from other comorbidities for a separate list, given the key nature of the date of cryptococcus diagnosis for subsequent analyses.\n\n\nCode\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n\n#Format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/load_data.html#further-development-of-the-strobe-flowchart",
    "href": "quarto/load_data.html#further-development-of-the-strobe-flowchart",
    "title": "Create cohort",
    "section": "Further development of the STROBE flowchart",
    "text": "Further development of the STROBE flowchart\nSubsequently, key diagnosis dates, including the date of cryptococcosis diagnosis, are merged into the analytic patient dataset.\nThis code block then extends the STROBE flowchart by integrating diagnosis timing, eligibility criteria, and coverage requirements to finalize the analytic cohorts. Patients are classified as cryptococcosis cases or potential controls based on the presence and timing of diagnosis, and sequential exclusion criteria are applied to ensure incident disease, adult status at diagnosis, and appropriate calendar-time eligibility.\nThe verify_medicare_primary() function from the usrds package is used to confirm that patients with a cryptococcus diagnosis have Medicare primary coverage for at least 365 days prior to the cryptococcus diagnosis date to ensure that the diagnosis is new and not a carryover from an unobserved period.\nThese steps culminate in the final case and control cohorts, with all inclusion and exclusion decisions explicitly tracked and visualized in the updated STROBE flow diagram.\n\n\nCode\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/load_data.html#creation-of-a-time-varying-cohort",
    "href": "quarto/load_data.html#creation-of-a-time-varying-cohort",
    "title": "Create cohort",
    "section": "Creation of a time-varying cohort",
    "text": "Creation of a time-varying cohort\nWe use several functions from the usRds package:\n\ncreate_usrds_cohort()\nadd_cohort_covariate()\nfinalize_usrds_cohort()\n\nThese functions split each patient into multiple rows, with each row describing a discrete period of time. This captures that patients will have time-varying status for covariates such as cirrhosis status, etc.\nPatients with cryptococcus infection join the cohort on the date of cryptococcosis diagnosis, while patients without cryptococcus (potential controls) join on the date of their first kidney transplant.\n“Time since transplant” resets after each new transplant.\n\n\nCode\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/load_data.html#other-portions-of-the-analysis",
    "href": "quarto/load_data.html#other-portions-of-the-analysis",
    "title": "Load data",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/set_isochrones.html",
    "href": "quarto/set_isochrones.html",
    "title": "Create cohort",
    "section": "",
    "text": "The code in this script creates the cohort of kidney transplant patients eligible for the study for use in other scripts.",
    "crumbs": [
      "Data Processing",
      "Set isochrones"
    ]
  },
  {
    "objectID": "quarto/set_isochrones.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "href": "quarto/set_isochrones.html#initial-data-loading-and-preprocessing-of-usrds-core-and-transplant-files",
    "title": "Create cohort",
    "section": "Initial data loading and preprocessing of USRDS core and transplant files",
    "text": "Initial data loading and preprocessing of USRDS core and transplant files\nThis portion of the code imports files from the USRDS data set necessary for the cryptococcus analysis. This portion makes use of the load_usrds_data() function from the usRds package as well as several tidyverse cleaning functions.\nKey files used:\n\npatients: This is a part of the Core data set of the USRDS and contains key patient demographics.\ntx: Also a part of the Core data set of the USRDS and contains summary information about kidney transplants from UNOS.\ntxunos_trr_ki and txunos_trr_kp: Part of the transplant data set of the USRDS, these files contain more detailed information derived from UNOS that is part of the Scientific Registry of Transplant Recipients.\n\nThe code below loads and merges transplant records across multiple UNOS-derived files, constructs a cumulative transplant count per patient, and reshapes the data into a time-varying format that tracks graft status over time.\n\n\nCode\n#Import core demographics from \"patients\" file\npatients_raw&lt;-usRds::load_usrds_file(\"patients\")%&gt;%\n  select(-ZIPCODE) #This is ZIP code at time of USRDS initiation, but we want at time of crypto dx\n\n#Import key information about the transplants from the TX and UNOS databases\ntx_raw&lt;-usRds::load_usrds_file(\"tx\")%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, TRR_ID_CODE)\n\nki_raw&lt;-usRds::load_usrds_file(\"txunos_trr_ki\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\nkp_raw&lt;-usRds::load_usrds_file(\"txunos_trr_kp\")%&gt;%\n  select(USRDS_ID, ORGTYP, HRTX, LUTX, INTX, LITX,PITX,BMTX, TRR_ID_CODE)\n\n#This combines the three datasets\ntx_clean&lt;-tx_raw%&gt;%\n  left_join(bind_rows(ki_raw,\n                      kp_raw))%&gt;%\n  arrange(USRDS_ID, TDATE)%&gt;%\n  \n  group_by(USRDS_ID)%&gt;%\n  mutate(cumulative_transplant_total=row_number())%&gt;%\n  ungroup\n\n#Create a time-varying dataset that can be used to track whether a pt has an active or inactive graft and the cumulative number of txs\ntx_status&lt;-tx_clean%&gt;%\n  select(USRDS_ID, TDATE, FAILDATE, cumulative_transplant_total)%&gt;%\n  pivot_longer(\n    cols = c(TDATE, FAILDATE),\n    names_to = \"event_type\",\n    values_to = \"event_date\"\n  ) %&gt;%\n  filter(!is.na(event_date)) %&gt;%\n  mutate(\n    graft_status = case_when(\n      event_type == \"TDATE\" ~ \"Active\",\n      event_type == \"FAILDATE\" ~ \"Failed\"\n    )\n  ) %&gt;%\n  select(-event_type)%&gt;%\n  arrange(USRDS_ID, cumulative_transplant_total, event_date, graft_status)",
    "crumbs": [
      "Data Processing",
      "Set isochrones"
    ]
  },
  {
    "objectID": "quarto/set_isochrones.html#initialize-flowchart",
    "href": "quarto/set_isochrones.html#initialize-flowchart",
    "title": "Create cohort",
    "section": "Initialize flowchart",
    "text": "Initialize flowchart\nThe next component makes use of the flowchart package. This package combines two key processes in an epidemiologic analysis:\n\nDataset preparation: Sequential application of eligibility criteria to define the analytic cohort, with explicit tracking of excluded records at each step.\nSTROBE diagram preparation: STrengthening the Reporting of OBservational studies in Epidemiology diagrams visually depict the process of including/excluding patients in an observational study and grouping them into cohorts. Many journals require these as a standard Figure 1.\n\nThe code below initializes a flowchart-aware cohort object and applies sequential eligibility filters, retaining both inclusion counts and labeled exclusion steps for downstream reporting.\n\n\nCode\n#Initialize a flowchart cohort\npatients_clean&lt;-patients_raw%&gt;%\n  as_fc(label=\"Patients in USRDS\")%&gt;%\n  \n  \n  fc_filter(TOTTX&gt;0, \n            label=\"Prior transplant\", \n            label_exc = \"Excluded: No prior transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter(TX1DATE&lt;as.Date(\"2021-01-01\"), \n            label=\"Transplant prior to 2021\", \n            label_exc = \"Excluded: Transplant 2021 or later\", \n            show_exc = TRUE)",
    "crumbs": [
      "Data Processing",
      "Set isochrones"
    ]
  },
  {
    "objectID": "quarto/set_isochrones.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "href": "quarto/set_isochrones.html#identification-of-comorbidities-and-confirmation-of-medicare-coverage-continuity",
    "title": "Create cohort",
    "section": "Identification of comorbidities and confirmation of Medicare coverage continuity",
    "text": "Identification of comorbidities and confirmation of Medicare coverage continuity\nThis component identifies baseline comorbidities among transplant recipients using diagnosis codes derived from Medicare Institutional (Part A) and physician/supplier (Part B) claims. Diagnosis code lists defined in R/setup.R are applied uniformly across claims files to establish the presence and timing of comorbid conditions.\nThis portion makes use of the get_IN_ICD() and get_PS_ICD() functions from the usRds package to obtain dates that specific ICD codes are used for patients with a history of at least one kidney transplant in the study period.\nThe establish_dx_date() function from the usRds package uses the results of this analysis to ascertain the date when comorbidities meet the criteria for a formal diagnosis:\n\nTwo outpatient encounters or\nOne inpatient encounter\n\nIn parallel, Medicare coverage history is retrieved for all transplant recipients from the payhist file, which is part of the Core dataest. These data will be used to confirm continuous enrollment during the analytic period. We verify the absence of gaps indicating missing data, noting that every subsequent period in the dataset for a patient starts the day after the previous period ends and thereby supporting valid longitudinal assessment of diagnoses and downstream cost analyses.\nFinally, we separate cryptococcus diagnosis dates from other comorbidities for a separate list, given the key nature of the date of cryptococcus diagnosis for subsequent analyses.\n\n\nCode\n#Create list of USRDS ids for patients who have undergone transplant\ntransplant_id_list&lt;-patients_clean$data%&gt;%\n  pull(USRDS_ID)\n\n# We now seek to determine comorbidities by using diagnosis codes from the setup.R file\n\ncomorbidity_diagnosis_date&lt;-list()\n\n# Combine all ICD codes from all comorbidities into one list \ncomorbidity_ICD_combined_list&lt;-unlist(comorbidity_ICD_list, use.names=FALSE)\n\n#Scrape files for any comorbidity claim\ncomorbidity_claims_df&lt;-bind_rows(get_IN_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list ),\n                                 get_PS_ICD(icd_codes = comorbidity_ICD_combined_list, \n                                            years = 2006:2021, \n                                            usrds_ids = transplant_id_list )%&gt;%rename(CODE=DIAG))%&gt;%\n  arrange(USRDS_ID, CLM_FROM)\n\n#Create comorbidity_diagnosis_date data frame\nfor (comorbidity in names(comorbidity_ICD_list)){\n  \n  comorbidity_diagnosis_date[[comorbidity]]&lt;-comorbidity_claims_df%&gt;%\n    filter(CODE %in% comorbidity_ICD_list[[comorbidity]])%&gt;%\n    establish_dx_date(diagnosis_established = comorbidity)\n}\n\n#Load Medicare coverage history for all patients with transplant\nmedicare_history&lt;-load_usrds_file(\"payhist\",\n                                  usrds_ids = transplant_id_list)%&gt;%\n  arrange(USRDS_ID, BEGDATE)%&gt;%\n  group_by(USRDS_ID)%&gt;%\n  mutate(lag_ENDDATE=lag(ENDDATE))%&gt;%\n  mutate(gap=as.numeric(BEGDATE-lag_ENDDATE))%&gt;%\n  arrange(desc(gap))\n\n#Confirm no gaps (gap should always be 1 or missing)\nif (any(!is.na(medicare_history$gap) & medicare_history$gap != 1)) {\n  stop(\"Gap assumption violated: `gap` contains values other than 1 or NA.\")\n}\n\n\n#Format a df with the cryptococcus dx\ncryptococcus_df&lt;-comorbidity_diagnosis_date$cryptococcus%&gt;%\n  select(-diagnosis)%&gt;%\n  rename(cryptococcus_dx_date=date_established)",
    "crumbs": [
      "Data Processing",
      "Set isochrones"
    ]
  },
  {
    "objectID": "quarto/set_isochrones.html#further-development-of-the-strobe-flowchart",
    "href": "quarto/set_isochrones.html#further-development-of-the-strobe-flowchart",
    "title": "Create cohort",
    "section": "Further development of the STROBE flowchart",
    "text": "Further development of the STROBE flowchart\nSubsequently, key diagnosis dates, including the date of cryptococcosis diagnosis, are merged into the analytic patient dataset.\nThis code block then extends the STROBE flowchart by integrating diagnosis timing, eligibility criteria, and coverage requirements to finalize the analytic cohorts. Patients are classified as cryptococcosis cases or potential controls based on the presence and timing of diagnosis, and sequential exclusion criteria are applied to ensure incident disease, adult status at diagnosis, and appropriate calendar-time eligibility.\nThe verify_medicare_primary() function from the usrds package is used to confirm that patients with a cryptococcus diagnosis have Medicare primary coverage for at least 365 days prior to the cryptococcus diagnosis date to ensure that the diagnosis is new and not a carryover from an unobserved period.\nThese steps culminate in the final case and control cohorts, with all inclusion and exclusion decisions explicitly tracked and visualized in the updated STROBE flow diagram.\n\n\nCode\n#Join cryptococcus date to fc cohort\npatients_clean$data&lt;-left_join(patients_clean$data, \n                               cryptococcus_df)%&gt;%\n  mutate(cryptococcus_case=ifelse(is.na(cryptococcus_dx_date), \"Potential control\", \"Case\"))\n\n#Continue to create analytic cohort\npatients_merged&lt;-patients_clean%&gt;%\n  \n  #Remove patients with a diagnosis of cryptococcus prior to transplant\n  fc_filter(cryptococcus_dx_date&gt;TX1DATE | is.na(cryptococcus_dx_date), \n            label=\"No cryptococcus dx prior to transplant\", \n            label_exc = \"Excluded: cryptococcus dx prior to transplant\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((time_length(interval(BORN, cryptococcus_dx_date), \"years\") &gt;= 18) | is.na(cryptococcus_dx_date),\n            label=\"Age 18+ at time of cryptococcus if cryptococcus patient\", \n            label_exc = \"Excluded: First cryptococcus prior to age 18\", \n            show_exc = TRUE)%&gt;%\n  \n  fc_filter((year(cryptococcus_dx_date)&gt;=2007 & year(cryptococcus_dx_date)&lt;=2020) | is.na(cryptococcus_dx_date),\n            label=\"Incident cryptococcus between 1/1/2007 and 12/31/2020\", \n            label_exc = \"Incident cryptococcus outside of specified date range\", \n            show_exc = TRUE)%&gt;%\n  \n  #Split cohorts\n  fc_split(cryptococcus_case)\n  \n  #Check Medicare coverage for 365-day lookback period from day of first episode of cryptococcus\npatients_merged$data&lt;-patients_merged$data%&gt;%\n  verify_medicare_primary(index_date = \"cryptococcus_dx_date\",\n                          lookback_days = 365,\n                          coverage_start_variable = \"coverage_start_date\",\n                          coverage_end_variable = \"coverage_end_date\"\n                          )%&gt;%\n  mutate(medicare_primary_TF=ifelse(cryptococcus_case==\"Potential control\", TRUE, medicare_primary_TF))\n  \npatients_merged2&lt;-patients_merged%&gt;%\n  \n  fc_filter(medicare_primary_TF==TRUE, \n            label = \"365+ days of Medicare primary coverage\\nprior to first cryptococcus claim\", \n            label_exc = \"Excluded: Fewer than 365 days of coverage\",\n            show_exc = TRUE)\n\npatients_merged2$data&lt;-patients_merged2$data%&gt;%\n  select(-medicare_primary_TF)%&gt;%\n  \n  #Prepare data for cohort initialization\n  mutate(terminal_date=coalesce(coverage_end_date, censor_date))\n\npatients_merged2&lt;-patients_merged2%&gt;%\n  fc_filter((terminal_date - cryptococcus_dx_date &gt;=minimum_followup) | is.na(cryptococcus_dx_date), \n            label = \"Minimum followup exceeded\", \n            label_exc= \"Excluded: Minimum follow-up threshold not met\",\n            show_exc = TRUE)\n\n  \npatients_merged2%&gt;%\n  fc_draw()",
    "crumbs": [
      "Data Processing",
      "Set isochrones"
    ]
  },
  {
    "objectID": "quarto/set_isochrones.html#creation-of-a-time-varying-cohort",
    "href": "quarto/set_isochrones.html#creation-of-a-time-varying-cohort",
    "title": "Create cohort",
    "section": "Creation of a time-varying cohort",
    "text": "Creation of a time-varying cohort\nWe use several functions from the usRds package:\n\ncreate_usrds_cohort()\nadd_cohort_covariate()\nfinalize_usrds_cohort()\n\nThese functions split each patient into multiple rows, with each row describing a discrete period of time. This captures that patients will have time-varying status for covariates such as cirrhosis status, etc.\nPatients with cryptococcus infection join the cohort on the date of cryptococcosis diagnosis, while patients without cryptococcus (potential controls) join on the date of their first kidney transplant.\n“Time since transplant” resets after each new transplant.\n\n\nCode\n#Now we need to construct the time-varying data set\n\n#Ungroup\ninitial_cohort&lt;-patients_merged2$data%&gt;%\n  ungroup()%&gt;%\n\n#Cases join when they experience cryptococcus\n#Controls start on date of first transplant\n  mutate(\n    cohort_join_date = coalesce(\n      as.Date(cryptococcus_dx_date),\n      as.Date(TX1DATE)\n    )\n  )\n\n#Initialize cohort\nprematching_cohort&lt;-create_usrds_cohort(df=initial_cohort,\n                            start_date = \"cohort_join_date\",\n                            end_date = \"terminal_date\")%&gt;%\n  \n  # Add cirrhosis\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"cirrhosis\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"cirrhosis\")%&gt;%\n  \n  # Add CMV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"CMV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"CMV\")%&gt;%\n  \n  # Add diabetes\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Diabetes\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"diabetes\")%&gt;%\n  \n  # Add HIV\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"HIV\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"HIV\")%&gt;%\n  \n  # Add liver transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Liver transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"liver_transplant\")%&gt;%\n  \n  # Add lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"lung_transplant\")%&gt;%\n  \n  # Add heart transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heart_transplant\")%&gt;%\n  \n  # Add pancreas transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Pancreas transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"pancreas_transplant\")%&gt;%\n  \n  # Add heart-lung transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Heart-lung transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"heartlung_transplant\")%&gt;%\n  \n  # Add intestinal transplant\n  add_cohort_covariate(covariate_data_frame=comorbidity_diagnosis_date[[\"Intestinal transplant\"]],\n                       covariate_date=\"date_established\",\n                       covariate_variable_name=\"intestinal_transplant\")%&gt;%\n  \n  #Add time-varying information about transplant status\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"cumulative_transplant_total\",\n                       covariate_value = \"cumulative_transplant_total\")%&gt;%\n  \n  #Add time-varying information about transplant status (whether current graft is active or failed)\n  add_cohort_covariate(covariate_data_frame=tx_status,\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"current_graft_status\",\n                       covariate_value = \"graft_status\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent transplant)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Active\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_transplant_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  #Add time-varying information about transplant status (date of most recent graft failure)\n  add_cohort_covariate(covariate_data_frame=tx_status%&gt;%filter(graft_status==\"Failed\"),\n                       covariate_date=\"event_date\",\n                       covariate_variable_name=\"most_recent_failure_date\",\n                       covariate_value = \"event_date\")%&gt;%\n  \n  # Add Medicare current coverage\n  add_cohort_covariate(covariate_data_frame=medicare_history,\n                       covariate_date=\"BEGDATE\",\n                       covariate_variable_name=\"current_medicare_coverage\",\n                       covariate_value = \"PAYER\"\n                       )%&gt;%\n  \n  finalize_usrds_cohort(baseline_date_variable = \"most_recent_transplant_date\")\n\n\nThe analysis then proceeds on to the execute_matching component.",
    "crumbs": [
      "Data Processing",
      "Set isochrones"
    ]
  },
  {
    "objectID": "quarto/set_isochrones.html#other-portions-of-the-analysis",
    "href": "quarto/set_isochrones.html#other-portions-of-the-analysis",
    "title": "Create cohort",
    "section": "Other portions of the analysis",
    "text": "Other portions of the analysis\n\nSetup: Defines global paths, data sources, cohort inclusion criteria, and analysis-wide constants.\nFunctions: Reusable helper functions for cohort construction, matching, costing, and modeling.\nExecute matching: Implements risk-set–based greedy matching without replacement to construct the analytic cohort.\nPost-match processing: Derives analytic variables, time-aligned cost windows, and follow-up structure after matching.\nModeling: Fits prespecified cost and outcome models using the matched cohort.\nTables: Summary tables and regression outputs generated from the final models.\nFigures:Visualizations of costs, risks, and model-based estimates.\nAbout: methods, assumptions, and disclosures",
    "crumbs": [
      "Data Processing",
      "Set isochrones"
    ]
  },
  {
    "objectID": "quarto/functions.html#drawing-60-minute-isocrhones-around-each-transplant-center",
    "href": "quarto/functions.html#drawing-60-minute-isocrhones-around-each-transplant-center",
    "title": "Functions",
    "section": "Drawing 60 minute isocrhones around each transplant center",
    "text": "Drawing 60 minute isocrhones around each transplant center\nThe following function uses the mapboxapi package to calculate 60-minute travel isochrones around each transplant center.\nThe function assumes the that you have an API token configured in R. For details of how to do this, see the package documentation.\nIts inputs are as follows:\n\nSFObject: This is an object of class sf that contains the location of each transplant center\nyear: year as a character. Must be a year in yearlist defined in R/setup.R.\n\n\n\nCode\n#Define a function that takes an SF data object and returns 60 minute isochrones\nset_60_min_isochrone_at_7AM&lt;-function(SFObject, year) {\n  \n  if (nrow(SFObject) == 0) {\n    return(\n      SFObject %&gt;%\n        st_transform(5070)\n    )\n  }else{\n    tempDF&lt;-SFObject%&gt;%\n      mutate(TimeZone=tz_lookup(., method=\"accurate\"))%&gt;%\n      st_transform(4326)\n    \n    FinalDF &lt;- vector(\"list\", length(timezones))\n    \n    \n    for(i in 1:length(timezones))\n    {\n      TZ&lt;-converted_times[[year]][[i,1]]\n      \n      UTCTime&lt;-format(converted_times[[year]][[i,3]], \"%Y-%m-%dT%H:%M:%SZ\")\n      \n      if (nrow(filter(tempDF,TimeZone==TZ))&gt;0)\n      {\n        temp&lt;-tempDF%&gt;%\n          filter(TimeZone==TZ)%&gt;%\n          mb_isochrone(time = 60, \n                       profile = \"driving-traffic\",\n                       depart_at = UTCTime,\n                       id_column = \"OTCCode\")%&gt;%\n          rename(OTCCode=id)\n        FinalDF[[i]]&lt;-temp\n      }\n    }\n    \n    FinalDF%&gt;%\n      bind_rows()%&gt;%\n      st_transform(5070)%&gt;%\n      return()\n  }\n}",
    "crumbs": [
      "Data Loading & Setup",
      "Functions"
    ]
  },
  {
    "objectID": "quarto/functions.html#converting-data-frame-of-summary-results-into-a-gt-format-table",
    "href": "quarto/functions.html#converting-data-frame-of-summary-results-into-a-gt-format-table",
    "title": "Functions",
    "section": "converting data frame of summary results into a gt format table",
    "text": "converting data frame of summary results into a gt format table\nInset LLM text here\n\n\nCode\nconvert_resultsdf_to_table&lt;-function(resultsdf, \n                                     year_list_fn=year_list,\n                                     row_values,\n                                     row_labels,\n                                     table_title){\n  \n  \n  resultsdf%&gt;%\n    \n    #Reshape data set\n    pivot_wider(\n      names_from = Year,\n      values_from = c(Numerator, Denominator, Percentage),\n      names_vary = \"slowest\"\n    )%&gt;%\n    \n    #Use the table defined above to turn Characteristic into a factor variable\n    mutate(Characteristic=factor(Characteristic,\n                                 levels = row_values,\n                                 labels = row_labels))%&gt;%\n    arrange(Characteristic)%&gt;%\n    \n    #Convert to a gt format table\n    gt()%&gt;%\n    \n    #Groups columns by year with a spanner label\n    {\n      purrr::reduce(\n        year_list_fn,\n        ~ .x %&gt;%\n          tab_spanner(\n            label = .y,\n            columns = matches(paste0(\"_\", .y, \"$\"))\n          ),\n        .init = .\n      )\n    } %&gt;%\n    \n    #Sets coluns to round to 0 decimal places for numbers and 1 decimal place for percentages\n    fmt_number(\n      columns = matches(paste0(\"Numerator_|Denominator_\")),\n      decimals = 0,\n      use_seps = TRUE\n    ) %&gt;%\n    fmt_number(\n      columns = matches(\"Percentage_\"),\n      decimals = 1\n    )%&gt;%tab_header(\n      title = table_title\n    )%&gt;%\n    \n    #Removes \"_year\" from columns\n    cols_label_with(~ \"Numerator\",   columns = matches(\"^Numerator_\")) %&gt;%\n    cols_label_with(~ \"Denominator\", columns = matches(\"^Denominator_\")) %&gt;%\n    cols_label_with(~ \"Percentage\",  columns = matches(\"^Percentage_\"))%&gt;%\n    \n    #Shades columns by year for easier reading\n    \n    {\n      purrr::reduce(\n        seq_along(year_list_fn),\n        ~ .x %&gt;%\n          tab_style(\n            style = cell_fill(\n              color = colorRampPalette(c(\"lightgray\",\"lightblue\"))(\n                length(year_list_fn)\n              )[.y]            ),\n            locations = cells_body(\n              columns = matches(paste0(\"_\", year_list_fn[.y], \"$\"))\n            )\n          ),\n        .init = .\n      )\n    }%&gt;%\n    \n    #Add separators between years\n    {\n      purrr::reduce(\n        seq_len(length(year_list_fn) - 1),\n        ~ .x %&gt;%\n          tab_style(\n            style = cell_borders(\n              sides = \"right\",\n              weight = px(2),\n              color = \"black\"\n            ),\n            locations = cells_body(\n              columns = matches(paste0(\"Percentage_\", year_list_fn[.y], \"$\"))\n            )\n          ) %&gt;%\n          tab_style(\n            style = cell_borders(\n              sides = \"left\",\n              weight = px(2),\n              color = \"black\"\n            ),\n            locations = cells_body(\n              columns = matches(paste0(\"Numerator_\", year_list_fn[.y + 1], \"$\"))\n            )\n          ),\n        .init = .\n      )\n    }\n  \n  \n}\n\n\n}",
    "crumbs": [
      "Data Loading & Setup",
      "Functions"
    ]
  },
  {
    "objectID": "quarto/functions.html#creates-paired-plots-of-maps-with-percentages-in-the-plot",
    "href": "quarto/functions.html#creates-paired-plots-of-maps-with-percentages-in-the-plot",
    "title": "Functions",
    "section": "Creates paired plots of maps with percentages in the plot",
    "text": "Creates paired plots of maps with percentages in the plot\nLLM text\n\n\nCode\nmake_paired_plot&lt;-function(organ,\n                           distance,\n                           outcome,\n                           buffer_list,\n                           year1=\"2017\",\n                           year2=\"2022\",\n                           plottitle,\n                           include_nonHIV=FALSE)\n{\n  \n  # ----Error checking----\n  \n  # Validate include_nonHIV\n  if (!is.logical(include_nonHIV) || length(include_nonHIV) != 1 || is.na(include_nonHIV)) {\n    stop(\"include_nonHIV must be a single TRUE or FALSE value.\")\n  }\n  \n  \n  #Access name of object passed to `buffer_list`\n  buffer_name &lt;- deparse(substitute(buffer_list))\n  \n  #Make sure name of outcome matches buffer_list\n  if (!stringr::str_detect(\n    stringr::str_to_lower(buffer_name),\n    stringr::str_to_lower(outcome)\n  )) {\n    warning(glue::glue(\n      \"Buffer object ('{buffer_name}') may not match outcome '{outcome}'.\"\n    ))\n  }\n  \n  if (!year1 %in% year_list) {\n    stop(glue::glue(\"year1 ({year1}) is not in year_list.\"))\n  }\n  \n  if (!year2 %in% year_list) {\n    stop(glue::glue(\"year2 ({year2}) is not in year_list.\"))\n  }\n  \n  if (!outcome %in% c(\"active\", \"HIV\", \"HOPE\")) {\n    stop(glue::glue(\"outcome ({outcome}) is not in c('active', 'HIV', 'HOPE').\"))\n  }\n  \n  # ----Main function----\n  \n  #Keep only elements of Results_HIV_df necessary for plot\n  summary_df_HIV&lt;-Results_HIV_df[[organ]]%&gt;%\n    filter(str_detect(Characteristic, outcome))%&gt;%\n    filter(str_detect(Characteristic, distance))\n  \n  #parameters of plot assigned\n  parameter_plot&lt;-list()\n  parameter_plot$y_title&lt;-0.9\n  parameter_plot$y_footnote&lt;-0.1\n  \n  if (include_nonHIV)\n  {\n    parameter_plot$y_title&lt;-0.97\n    parameter_plot$y_footnote&lt;-0.01\n  }\n  \n  \n  #Keep only elements of Results_nonHIV_df necessary for plot, if even needed in the first place\n  if (include_nonHIV)\n  {\n    summary_df_nonHIV&lt;-Results_nonHIV_df[[organ]]%&gt;%\n      filter(str_detect(Characteristic, outcome))%&gt;%\n      filter(str_detect(Characteristic, distance))\n  }\n  \n  #Creates text for nonHIV (is NULL if )\n  title_text_nonHIV&lt;-list()\n  \n  if (include_nonHIV==TRUE) {\n    title_text_nonHIV[[year1]]&lt;-\n      glue(\"&lt;br&gt;\",\n           \"&lt;span style='font-size:30pt; font-weight:normal;'&gt;HIV negative:&lt;/span&gt; \",\n           \"&lt;span style='font-size:30pt; font-weight:bold;'&gt;\",\n           \"{summary_df_nonHIV$Percentage[summary_df_nonHIV$Year == as.numeric(year1)]}%\",\n           \"&lt;/span&gt;\",\n           \"&lt;br&gt;\",\n           \"{comma(summary_df_nonHIV$Numerator[summary_df_nonHIV$Year == as.numeric(year1)])}\",\n           \" / \",\n           \"{comma(summary_df_nonHIV$Denominator[summary_df_nonHIV$Year == as.numeric(year1)])}\")\n    \n    title_text_nonHIV[[year2]]&lt;-\n      glue(\"&lt;br&gt;\",\n           \"&lt;span style='font-size:30pt; font-weight:normal;'&gt;HIV negative:&lt;/span&gt; \",\n           \"&lt;span style='font-size:30pt; font-weight:bold;'&gt;\",\n           \"{summary_df_nonHIV$Percentage[summary_df_nonHIV$Year == as.numeric(year2)]}%\",\n           \"&lt;/span&gt;\",\n           \"&lt;br&gt;\",\n           \"{comma(summary_df_nonHIV$Numerator[summary_df_nonHIV$Year == as.numeric(year2)])}\",\n           \" / \",\n           \"{comma(summary_df_nonHIV$Denominator[summary_df_nonHIV$Year == as.numeric(year2)])}\")\n  }\n  else {\n    title_text_nonHIV[[year1]]&lt;-\"\"\n    title_text_nonHIV[[year2]]&lt;-\"\"\n  }\n  \n  \n  \n  #Left graph\n  Plot1&lt;-ggplot() +\n    geom_sf(data = county_dots_transformed[[year1]], size = 0.3, color = \"navy\", alpha = 0.5) +\n    theme_void() +\n    theme(\n      axis.title.y = element_text(size = 36, angle = 90, vjust = 0.5),\n      plot.title = element_textbox(size = 16, hjust = 0.5,\n                                   halign = 0.5)\n    )+\n    labs(y=year1,\n         title = glue(\"&lt;span style='font-size:30pt; font-weight:normal;'&gt;PLWH:&lt;/span&gt; \",\n                      \"&lt;span style='font-size:30pt; font-weight:bold;'&gt;\",\n                      \"{summary_df_HIV$Percentage[summary_df_HIV$Year == as.numeric(year1)]}%\",\n                      \"&lt;/span&gt;\",\n                      \"&lt;br&gt;\",\n                      \"{comma(summary_df_HIV$Numerator[summary_df_HIV$Year == as.numeric(year1)])}\",\n                      \" / \",\n                      \"{comma(summary_df_HIV$Denominator[summary_df_HIV$Year == as.numeric(year1)])}\",\n                      title_text_nonHIV[[year1]]\n         ))+\n    geom_sf(data=buffer_list[[organ]][[distance]][[year1]], color=\"red\", fill=NA)+\n    geom_sf(data=states_sf_transformed, fill=NA)\n  \n  \n  #Right plot\n  Plot2&lt;-ggplot() +\n    geom_sf(data = county_dots_transformed[[year2]], size = 0.3, color = \"navy\", alpha = 0.5) +\n    theme_void() +\n    theme(\n      axis.title.y = element_text(size = 36, angle = 90, vjust = 0.5),\n      plot.title = element_textbox(size = 16, hjust = 0.5,\n                                   halign = 0.5)\n    )+\n    labs(y=year2,\n         title = glue(\"&lt;span style='font-size:30pt; font-weight:normal;'&gt;PLWH:&lt;/span&gt; \",\n                      \"&lt;span style='font-size:30pt; font-weight:bold;'&gt;\",\n                      \"{summary_df_HIV$Percentage[summary_df_HIV$Year == as.numeric(year2)]}%\",\n                      \"&lt;/span&gt;\",\n                      \"&lt;br&gt;\",\n                      \"{comma(summary_df_HIV$Numerator[summary_df_HIV$Year == as.numeric(year2)])}\",\n                      \" / \",\n                      \"{comma(summary_df_HIV$Denominator[summary_df_HIV$Year == as.numeric(year2)])}\",\n                      title_text_nonHIV[[year2]]\n         ))+\n    geom_sf(data=buffer_list[[organ]][[distance]][[year2]], color=\"red\", fill=NA)+\n    geom_sf(data=states_sf_transformed, fill=NA)\n  \n  #Combine plots\n  combined&lt;-cowplot::plot_grid(Plot1, Plot2,\n                               ncol = 2, align = \"hv\")\n  \n  final_plot &lt;- ggdraw() +\n    draw_plot(combined) +\n    draw_label(\n      plottitle,\n      x = 0.5, y = parameter_plot$y_title,   # top center\n      hjust = 0.5, vjust = 1,   # anchor to the top edge\n      fontface = 'bold',\n      size = 25\n    )+\n    # \n    draw_label(\n      \"Each blue dot represents 100 people with HIV\\nRed outlines represent the catchment area for each transplant center\",\n      x = 0.02, y = parameter_plot$y_footnote,          # left margin position\n      hjust = 0, vjust = 0,        # align text to the left edge\n      size = 14,\n      fontface = \"italic\"\n    )\n  \n  return(final_plot)\n  \n}",
    "crumbs": [
      "Data Loading & Setup",
      "Functions"
    ]
  },
  {
    "objectID": "quarto/functions.html#plot-the-number-of-people-with-hiv-in-the-catchment-area-of-each-transplant-center",
    "href": "quarto/functions.html#plot-the-number-of-people-with-hiv-in-the-catchment-area-of-each-transplant-center",
    "title": "Functions",
    "section": "Plot the number of people with HIV in the catchment area of each transplant center",
    "text": "Plot the number of people with HIV in the catchment area of each transplant center\nThis function uses the ggbeeswarm package to make GraphPad Prism-type plots comparing the number of people living with HIV in the catchment area of each transplant center in the years specified.\n\n\nCode\nplot_center_HIV_catchment&lt;-function(organ,\n                                    distance,\n                                    buffer_list,\n                                    year1=\"2017\",\n                                    year2=\"2022\"){\n  \n  \n  \n  # ----Error checking----\n  \n  #Access name of object passed to `buffer_list`\n  buffer_name &lt;- deparse(substitute(buffer_list))\n  \n  if (!year1 %in% year_list) {\n    stop(glue::glue(\"year1 ({year1}) is not in year_list.\"))\n  }\n  \n  if (!year2 %in% year_list) {\n    stop(glue::glue(\"year2 ({year2}) is not in year_list.\"))\n  }\n  \n  \n  \n  temp_DF&lt;-list()\n  \n  temp_DF[[year1]]&lt;-buffer_list%&gt;%\n    pluck(year1)%&gt;%\n    st_drop_geometry()%&gt;%\n    group_by(OTCCode)%&gt;%\n    summarize(total_cases=round(sum(tract_cases), 0))%&gt;%\n    mutate(year=as.numeric(year1))%&gt;%\n    mutate(Center_classification=case_when(\n      OTCCode %in% HOPE_center_volumes[[organ]][[year1]]$REC_CTR_CD~\"HOPE center\",\n      OTCCode %in% HIV__center_volumes[[organ]][[year1]]$REC_CTR_CD~\"≥1 HIV R+ transplants\",\n      OTCCode %in% Active_tx_centers[[organ]][[year1]]~\"No HIV R+ transplants\"\n    ))%&gt;%\n    filter(!is.na(OTCCode))\n  \n  \n  temp_DF[[year2]]&lt;-buffer_list%&gt;%\n    pluck(year2)%&gt;%\n    st_drop_geometry()%&gt;%\n    group_by(OTCCode)%&gt;%\n    summarize(total_cases=round(sum(tract_cases), 0))%&gt;%\n    mutate(year=as.numeric(year2))%&gt;%\n    mutate(Center_classification=case_when(\n      OTCCode %in% HOPE_center_volumes[[organ]][[year2]]$REC_CTR_CD~\"HOPE center\",\n      OTCCode %in% HIV__center_volumes[[organ]][[year2]]$REC_CTR_CD~\"≥1 HIV R+ transplants\",\n      OTCCode %in% Active_tx_centers[[organ]][[year2]]~\"No HIV R+ transplants\"\n    ))%&gt;%\n    filter(!is.na(OTCCode))\n  \n  combined_DF&lt;-bind_rows(temp_DF)%&gt;%\n    mutate(Center_classification=factor(Center_classification,\n                                        levels=c(\"HOPE center\",\"≥1 HIV R+ transplants\", \"No HIV R+ transplants\"),\n                                        labels=c(\"HOPE center\",\"≥1 HIV R+ transplants\", \"No HIV R+ transplants\")\n    ))%&gt;%\n    mutate(Center_classification_color=case_when(\n      OTCCode %in% HOPE_center_volumes[[organ]][[year1]]$REC_CTR_CD~\"HOPE center\",\n      OTCCode %in% HIV__center_volumes[[organ]][[year1]]$REC_CTR_CD~\"≥1 HIV R+ transplants\",\n      OTCCode %in% Active_tx_centers[[organ]][[year1]]~\"No HIV R+ transplants\",\n      TRUE~glue(\"No transplants in {year1}\")\n    ))\n  \n  combined_DF %&gt;% ggplot()+\n    geom_violin(mapping = aes(x=Center_classification, y=total_cases), color = NA, alpha=0.5,fill = \"grey\", \n                draw_quantiles = 1)+\n    stat_summary(mapping = aes(x=Center_classification, y=total_cases),fun = median, \n                 fun.min = median, fun.max = median, \n                 geom = \"crossbar\", width = 0.9, fatten=1.5)+\n    geom_quasirandom(mapping = aes(x=Center_classification, y=total_cases, color=Center_classification_color), \n                     cex=2, alpha=0.7)+\n    stat_compare_means(method = \"kruskal.test\",\n                       mapping = aes(x = Center_classification, y = total_cases)) +\n    scale_y_continuous(labels = scales::comma)+\n    guides(color = guide_legend(title.position = \"top\", nrow = 1))+\n    theme_classic()+\n    theme(legend.position = \"bottom\",\n          legend.title = element_text(hjust = 0.5),  # centers title\n          legend.box = \"horizontal\")+\n    theme(axis.text.x = element_text(\n      angle = 45,\n      hjust = 1,\n      vjust = 1))+\n    facet_grid(.~year)+\n    labs(x = \"Center HIV R+ volume\", y=\"PLWH in catchment area\", color=glue(\"{year1} status\"))+\n    scale_color_discrete(breaks = c(\"HOPE center\",\n                                    \"≥1 HIV R+ transplants\", \n                                    \"No HIV R+ transplants\",\n                                    glue(\"No transplants in {year1}\"))\n    )\n  \n  \n  \n}",
    "crumbs": [
      "Data Loading & Setup",
      "Functions"
    ]
  },
  {
    "objectID": "quarto/load_data.html#load-us-state-maps-from-census",
    "href": "quarto/load_data.html#load-us-state-maps-from-census",
    "title": "Load data",
    "section": "Load US state maps from census",
    "text": "Load US state maps from census\nWe import U.S. state boundary shapefiles using the tigris package.\nThe tigris::states() function retrieves state-level shapefiles from the U.S. Census Bureau’s TIGER/Line products.\n\nColumn Selection\nWe retain only:\n\nNAME → full state name\nSTUSPS → two-letter state abbreviation\ngeometry → polygon boundaries\n\nThis reduces memory overhead and keeps the object lightweight for downstream joins and plotting.\n\n\nExclusions\nWe remove:\n\nAlaska and Hawaii (to avoid projection distortion in contiguous U.S. maps)\nU.S. territories (not included in SRTR transplant center analyses)\n\nThis ensures that visualizations align with the contiguous U.S. study population.\n\n\nOutput\nThe resulting object, states_sf, is an sf object containing polygon geometries for the 48 contiguous U.S. states,\n\n\nCode\nstates_sf &lt;- tigris::states(cb = TRUE, year = 2022)%&gt;%\n  select(NAME, STUSPS, geometry) %&gt;%\n  filter(!(NAME %in% c(\"Alaska\", \n                       \"Hawaii\", \n                       \"Puerto Rico\", \n                       \"United States Virgin Islands\",\n                       \"Commonwealth of the Northern Mariana Islands\",\n                       \"Guam\",\n                       \"American Samoa\"))) %&gt;%\n  rename(State=NAME)",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/load_data.html#import-transplant-data-from-unos-srtr",
    "href": "quarto/load_data.html#import-transplant-data-from-unos-srtr",
    "title": "Load data",
    "section": "Import transplant data from UNOS SRTR",
    "text": "Import transplant data from UNOS SRTR\nTo identify active transplant centers and characterize transplant activity by organ type, we import transplant recipient-level and donor-level data from the Scientific Registry of Transplant Recipients (SRTR).\nThese datasets are accessed using a custom helper function, load_srtr_file(), which standardizes file loading, variable labeling, and preprocessing across SRTR tables.\n\n\nCode\ntx&lt;-list()\n\ntx[[\"kidney\"]] &lt;- load_srtr_file(\"tx_ki\")\ntx[[\"liver\"]] &lt;- load_srtr_file(\"tx_li\")\ntx[[\"heart\"]] &lt;- load_srtr_file(\"tx_hr\")\ntx[[\"lung\"]] &lt;- load_srtr_file(\"tx_lu\")\ntx[[\"pancreas\"]] &lt;- load_srtr_file(\"tx_kp\")\n\n\n\ndonor_deceased &lt;- load_srtr_file(\"donor_deceased\")%&gt;%\n  select(DONOR_ID, DON_ANTI_HIV, DON_HIV_NAT)",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/load_data.html#load-transplant-center-data-from-srtr-package",
    "href": "quarto/load_data.html#load-transplant-center-data-from-srtr-package",
    "title": "Load data",
    "section": "Load transplant center data from SRTR package",
    "text": "Load transplant center data from SRTR package\nTo map transplant center locations and define geographic catchment areas, we retrieve center-level data from the Health Resources and Services Administration (HRSA) using the sRtr package.\nThe get_hrsa_transplant_centers() function accesses HRSA transplant center metadata, including center identifiers and geographic coordinates.\nSubsequent steps:\n\nRemove Hawaii and Puerto Rico\nKeep the following variables:\n\nOTC_NM: transplant center name\nOTC_CD: transplant center 4-letter UNOS code\nService_Lst: list of organs transplanted at that center\nX, Y: longitude and latitude of transplant center\n\nKeep transplant centers whose organ corresponds with the organ defined in the organ_loop variable for each loop\nRemoves duplicates with the distinct() command\nRenames variables for convenience\nPauses for five seconds between iterations to avoid overloading the HRSA website\n\n\n\nCode\nTransplant_centers_all&lt;-list()\n\nfor (organ_loop in organ_list)\n{\n  \n  \n  Transplant_centers_all[[organ_loop]]&lt;-sRtr::get_hrsa_transplant_centers()%&gt;%\n    filter(OPO_STATE_ABBR != \"PR\" & OPO_STATE_ABBR!= \"HI\")%&gt;%\n    select(OTC_NM, OTC_CD, Service_Lst, X, Y) %&gt;%\n    filter(str_detect(Service_Lst, str_to_sentence(organ_loop)))%&gt;%\n    select(-Service_Lst)%&gt;%\n    distinct()%&gt;%\n    rename(OTCName=OTC_NM, OTCCode=OTC_CD, Latitude=Y, Longitude=X)\n  Sys.sleep(5)\n  \n}",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/load_data.html#load-census-data",
    "href": "quarto/load_data.html#load-census-data",
    "title": "Load data",
    "section": "Load census data",
    "text": "Load census data\nTo estimate catchment populations for transplant centers, we retrieve tract- and county-level population data from the American Community Survey (ACS) 5-year files. Because these data are large and slow to download, we implement a caching strategy to avoid repeated API calls during iterative renders.\n\nOverview\nFor each year in year_list, this code:\n\nRetrieves tract-level total population\nRetrieves county-level total population\nCaches results locally as .rds files\n\nThis structure ensures reproducibility while dramatically improving performance during Quarto re-rendering.\n\n\nTract-Level Population Data\nWe obtain tract-level total population using ACS variable:\n\nB01003_001 — Total population\n\nIf a cached file already exists (cache/us_tracts_population_YEAR.rds), it is loaded directly. Otherwise:\n\nData are downloaded using get_acs()\nGeometry is included (geometry = TRUE) for spatial joins\nCounty FIPS codes are derived from the first five digits of the tract GEOID\nIdentifier fields are converted to numeric for efficient joins\nOnly necessary variables are retained\nThe cleaned dataset is saved locally for future use\n\n\nWhy include geometry?\nIncluding tract geometry allows direct spatial intersection with:\n\n50-mile buffers\n60-minute isochrones\nUnited catchment areas\n\nThis avoids needing a second shapefile join later.\n\n\n\nCounty-Level Population Data\nCounty-level total population is retrieved using the same ACS variable (B01003_001), with geometry retained.\nCounty data are used for:\n\nCounty-level HIV prevalence overlays\nAggregated catchment summaries\nValidation checks against tract-level totals\n\nAs with tract data, results are cached locally to prevent redundant API calls.\n\n\nAge and Sex Variable Labels (B01001)\nThe ACS table B01001 contains detailed age- and sex-specific population counts. Rather than downloading these counts directly in this step, we load the variable metadata using:\n\n\nCode\nus_tracts_population&lt;-list()\nus_counties_population&lt;-list()\nvars&lt;-list()\n\nfor (year_loop in year_list){\n  \n  \n  tracts_path&lt;-paste0(\"cache/us_tracts_population_\",year_loop,\".rds\")\n  counties_path&lt;-paste0(\"cache/us_counties_population_\",year_loop,\".rds\")\n  \n  #Pull US Census tract populations if cache file doesn't already exist\n  \n  if (file.exists(tracts_path)) {\n    us_tracts_population[[year_loop]] &lt;- readRDS(tracts_path)\n  } else {\n    \n    us_tracts_population[[year_loop]]&lt;-get_acs(\n      geography = \"tract\",\n      variables = \"B01003_001\",\n      year = as.numeric(year_loop),\n      survey = \"acs5\",\n      geometry = TRUE,\n      state = continental_fips\n    )%&gt;%\n      mutate(county_fips = substr(GEOID, 1, 5))%&gt;%\n      mutate(GEOID=as.numeric(GEOID))%&gt;%\n      mutate(county_fips=as.numeric(county_fips))%&gt;%\n      select(-variable, -moe)%&gt;%\n      rename(tract_population=estimate)\n    \n    saveRDS(us_tracts_population[[year_loop]], \n            tracts_path)\n    \n  }\n  \n  #Pull US Census counties populations if cache file doesn't already exist\n  \n  if (file.exists(counties_path)) {\n    us_counties_population[[year_loop]] &lt;- readRDS(counties_path)\n  } else {\n    \n    us_counties_population[[year_loop]]&lt;-get_acs(\n      geography = \"county\",\n      variables = \"B01003_001\",\n      year = as.numeric(year_loop),\n      survey = \"acs5\",\n      geometry = TRUE,\n      state = continental_fips\n    )%&gt;%\n      mutate(GEOID=as.numeric(GEOID))%&gt;%\n      select(-variable, -moe)%&gt;%\n      rename(county_population=estimate)\n    \n    saveRDS(us_counties_population[[year_loop]], \n            counties_path)\n    \n    \n  }\n  \n  # Load tract variable labels for age/sex values B01001 from the ACS 5-year 2017 dataset\n  vars[[year_loop]] &lt;- load_variables(year_loop, \"acs5\", cache = TRUE) %&gt;%\n    filter(str_detect(name, \"B01001_\"))%&gt;%\n    mutate(label = str_replace_all(label, \"Estimate!!Total!!\", \"\"))%&gt;%\n    mutate(label = str_replace_all(label, \"!!\", \"_\"))%&gt;%\n    mutate(label = str_replace_all(label, \" \", \"_\"))\n  \n}",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/load_data.html#atlasplus-county-level-hiv-data",
    "href": "quarto/load_data.html#atlasplus-county-level-hiv-data",
    "title": "Load data",
    "section": "AtlasPlus county-level HIV data",
    "text": "AtlasPlus county-level HIV data\nThis code uses the CDCAtlas package to download county-level HIV prevalence data for the years defined in year_list.\n\n\nCode\nAtlasPlusTableData_county_totals&lt;-list()\n\nfor (year_loop in year_list){\n  \n  AtlasPlusTableData_county_totals[[year_loop]] &lt;-CDCAtlas::get_atlas(disease=\"hiv\",\n                                                                      geography=\"county\",\n                                                                      year=as.numeric(year_loop))%&gt;%\n    clean_names()%&gt;%\n    rename(county_cases=cases)%&gt;%\n    rename(geo_id=fips)%&gt;%\n    rename(county_name=geography)%&gt;%\n    mutate(county_cases=if_else(is.na(county_cases),0, county_cases))%&gt;%\n    mutate(geo_id=as.numeric(geo_id))%&gt;%\n    filter(year==as.numeric(year_loop))%&gt;%\n    select(-year)%&gt;%\n    filter(indicator==\"HIV prevalence\")\n  \n}",
    "crumbs": [
      "Data Processing",
      "Load data"
    ]
  },
  {
    "objectID": "quarto/functions.html#drawing-60-minute-isochrones-around-each-transplant-center",
    "href": "quarto/functions.html#drawing-60-minute-isochrones-around-each-transplant-center",
    "title": "Functions",
    "section": "Drawing 60 minute isochrones around each transplant center",
    "text": "Drawing 60 minute isochrones around each transplant center\nThe following function uses the mapboxapi package to calculate 60-minute travel isochrones around each transplant center.\nThe function assumes the that you have an API token configured in R. For details of how to do this, see the package documentation.\nIts inputs are as follows:\n\nSFObject: This is an object of class sf that contains the location of each transplant center\nyear: year as a character. Must be a year in yearlist defined in R/setup.R.\n\n\n\nCode\n#Define a function that takes an SF data object and returns 60 minute isochrones\nset_60_min_isochrone_at_7AM&lt;-function(SFObject, year) {\n  \n  if (nrow(SFObject) == 0) {\n    return(\n      SFObject %&gt;%\n        st_transform(5070)\n    )\n  }else{\n    tempDF&lt;-SFObject%&gt;%\n      mutate(TimeZone=tz_lookup(., method=\"accurate\"))%&gt;%\n      st_transform(4326)\n    \n    FinalDF &lt;- vector(\"list\", length(timezones))\n    \n    \n    for(i in 1:length(timezones))\n    {\n      TZ&lt;-converted_times[[year]][[i,1]]\n      \n      UTCTime&lt;-format(converted_times[[year]][[i,3]], \"%Y-%m-%dT%H:%M:%SZ\")\n      \n      if (nrow(filter(tempDF,TimeZone==TZ))&gt;0)\n      {\n        temp&lt;-tempDF%&gt;%\n          filter(TimeZone==TZ)%&gt;%\n          mb_isochrone(time = 60, \n                       profile = \"driving-traffic\",\n                       depart_at = UTCTime,\n                       id_column = \"OTCCode\")%&gt;%\n          rename(OTCCode=id)\n        FinalDF[[i]]&lt;-temp\n      }\n    }\n    \n    FinalDF%&gt;%\n      bind_rows()%&gt;%\n      st_transform(5070)%&gt;%\n      return()\n  }\n}",
    "crumbs": [
      "Data Loading & Setup",
      "Functions"
    ]
  }
]